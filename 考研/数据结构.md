# 1.数据结构基本概念

---

## 1.1 数据结构三要素

**1.数据逻辑结构**：集合、线性结构、树状结构、图状结构 

**2.数据物理结构（存储结构）**：顺序存储、链式存储、索引存储、散列存储*

* 顺序存储-物理上是连续的，非顺序存储-离散
* 存储结构影响存储空间分配的方便性和数据运算速度

**3.顺序的运算**是针对存储结构的  

**4.数据类型**：一个值的集合和定义在此集合上的一组操作的总称

* 原子类型：其值不可再分
* 结构类型：其值可再分解为若干成分的数据类型

---

## 1.2 算法和算法分析

### 1.2.1 算法

程序=数据机构+算法

**特性**：

* 有穷性
* 确定性：对于相同的输入只能得到相同的输出
* 可行性：算法描述的操作都可以通过已经实现的基本运算执行有限次来实现
* 有输入输出

好算法：正确性、可读性、健壮性、高效低花费

### 1.2.2 算法效率的度量

时间复杂度和空间复杂度

**1.算法时间复杂度**

时间开销T(n)和问题规模n

可只考虑阶数高的部分，如T(n)=O[f(n)]

1. 加法规则：多项相加，只保留最高阶的项，且系数变为1
2. 乘法规则：多项相乘，都保留

算法的时间复杂度结论：

$$O(1)<O(\log_{2}(n))<O(n)<O(n\log_{2}(n))<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$$

**结论**：

1. 顺序执行的代码只会影响常数项，可以忽略
2. 只需挑循环中的一个基本操作分析它的执行次数与n的关系即可
3. 如果有多层嵌套循环，只需要关注最深层执行了多少次

**例题**：

![image-20250325200834632](C:\Users\GodsCat\AppData\Roaming\Typora\typora-user-images\image-20250325200834632.png)

**三种复杂度**：

* 最坏时间复杂度：考虑输入数据“最坏”的情况
* 平均时间复杂度：考虑所有输入数据都等概率出现的情况
* 最好时间复杂度：考虑输入数据“最好”的情况

**2.空间复杂度**

**普通程序**：

1. 找到所占空间大小与问题规模相关的变量
2. 分析所占空间x与问题规模n的关系x=f(n)
3. x的数量级O(x)就是算法空间复杂度S(n)
4. S(n)=O(f(n))

**递归程序**：

1. 找到递归调用深度x与问题规模n的关系x=f(n)
2. x的数量级O(x)就是算法空间复杂度S(n)
3. 有的算法各层所需存储空间不同，分析方法略有区别

**3. 抽象数据类型ADT**

---

---

# 2.线性表

定义：线性表是具有**相同**数据类型的n(n≥0)个数据元素的**有限序列**，L=(a1,a2,...,ai,ai+1,...,an)

基本操作：初始化、增删改查、排序等

---

## 2.1 顺序表

顺序表：用顺序存储的方式实现线性表顺序存储

顺序表存储结构：

```c
typedef int ElemType;

typedef struct {
    ElemType data[MAXSIZE]; // 数组存储元素
    int length;             // 当前顺序表长度，也是元素下标
}SeqList;
```

### 2.1.1 基本操作

**1.初始化**

> 使用数组创建顺序表
>
> * 初始化算法initList()
>
> ```c
> #define MAXSIZE 100
> typedef int ElemType;
> 
> typedef struct {
>     ElemType data[MAXSIZE]; // 数组存储元素
>     int length;             // 当前顺序表长度，也是元素下标
> }SeqList;
> 
> void initList(SeqList *L) {
>     L->length = 0; // 初始化空表长度为0
> }
> ```

**2.尾添加元素**

> * 尾部插入算法appendElem()
>
> ```C
> // 尾部插入
> int appendElem(SeqList *L, ElemType e) {
>     // 异常检查
>     if (L->length >= MAXSIZE) {
>         printf("顺序表已满，无法插入元素！\n");
>         return 0; 
>     }
>     
>     // 一般情况
>     L->data[L->length] = e; // 插入元素到顺序表的末尾
>     L->length++; // 更新顺序表的长度
>     return 1; // 插入成功
> }
> ```

**3.遍历**

>* 遍历操作listElem()
>
>```C
>// 遍历顺序表
>void listElem(SeqList *L) {
>    // 异常检查
>    if (L->length == 0) {
>        printf("顺序表为空！\n");
>        return; // 如果顺序表为空，直接返回
>    }
>
>    // 一般情况
>    printf("顺序表中的元素为：\n");
>    for (int i = 0; i < L->length; i++) {
>        printf("%d ", L->data[i]); // 打印顺序表中的每个元素
>    }
>    printf("\n"); // 换行
>}
>```

**4.插入元素**

顺序表插入数据的最好时间复杂度是： O(1) -末尾插入；最坏是： O(n) -首部插入 

> * 插入操作insertElem()
>
> ```C
> // 插入元素
> int insertElem(SeqList *L, int i, ElemType e)
> {
>     // 异常检查
>     if (L->length >= MAXSIZE)
>     {
>         printf("顺序表已满，无法插入元素！\n");
>         return 0; // 顺序表已满，插入失败
>     }
>     if (i < 0 || i > L->length)
>     {
>         printf("插入位置不合法！\n");
>         return 0; // 插入位置不合法，插入失败
>     }
> 
>     // 一般情况
>     for (int j = L->length; j > i; j--)
>     {
>         L->data[j] = L->data[j - 1]; // 将插入位置及其后面的元素后移一位
>     }
>     L->data[i] = e; // 在指定位置插入新元素
>     L->length++;    // 更新顺序表的长度
>     return 1;       // 插入成功
> }
> ```

**5.删除元素**

> * 删除元素deleteElem()
>
> ```C
> // 删除元素
> int deleteElem(SeqList *L, int i, ElemType *e)
> {
>     // 异常检查
>     if (L->length == 0)
>     {
>         printf("顺序表为空，无法删除元素！\n");
>         return 0; // 顺序表为空，删除失败
>     }
>     if (i < 0 || i >= L->length)
>     {
>         printf("删除位置不合法！\n");
>         return 0; // 删除位置不合法，删除失败
>     }
> 
>     // 一般情况
>     *e = L->data[i]; // 保存被删除的元素
>     for (int j = i; j < L->length - 1; j++)
>     {
>         L->data[j] = L->data[j + 1]; // 将删除位置后面的元素前移一位
>     }
>     L->length--; // 更新顺序表的长度
>     return 1;    // 删除成功
> }
> ```

**6.查找**

查找第一次出现的位置

> * 查找
>
> ```c
> // 查找元素
> int findElem(SeqList *L, ElemType e)
> {
>     // 异常检查
>     if (L->length == 0)
>     {
>         printf("顺序表为空，无法查找元素！\n");
>         return -1; // 顺序表为空，查找失败
>     }
> 
>     // 一般情况
>     for (int i = 0; i < L->length; i++)
>     {
>         if (L->data[i] == e)
>         {
>             return i + 1; // 返回元素的下标+1(从1开始)
>         }
>     }
>     return -1; // 元素未找到，返回-1
> }
> ```

**7.动态分配内存地址初始化**

在堆内存开辟空间进行存储

* 使用malloc(unsigned int num_bytes)函数
* malloc()函数默认返回void*类型，即通用数据类型，需进行类型转换
* 使用完记得手动free()释放内存空间

> * 动态分配内存地址初始化
>
> ```c
> // 动态分配内存初始化
> SeqList* initListDynamic()
> {
>     SeqList* L = (SeqList *)malloc(sizeof(SeqList)); // 为顺序表分配内存
>     if (L == NULL)
>     {
>         printf("内存分配失败！\n");
>         return NULL; // 分配失败，返回NULL
>     }
>     L->length = 0; // 初始长度为0
>     return L;      // 返回初始化后的顺序表指针
> }
> ```

---

## 2.2 链表-单链表，带头结点

线性表链式存储结构的特点：用一组任意的存储单元存储线性表的数据单元（这组存储单元可以使连续的，也可以是不连续的）

对数据元素ai来说，除了其本身的信息之外，还需要存储一个指示其直接后继的信息（直接后继存储位置）。这两部分信息组成数据元素ai的存储映像，称为**结点（node）**。

结点包括数据域和指针域。

**头结点**：

* 第一个结点之前附设的一个节点
* 头结点的**数据域**可不存储任何信息，也可存储**如线性表长度**等类的附加信息

**链表存储结构：**

```c
typedef int ElemType;

typedef struct node{ // 必须添加结构体标签
    ElemType data; // 数据域
    struct node* next; // 指针域，指向下一个节点
}Node;
```

### 2.1.1 基本操作

**1.初始化**

创建带头结点，指针域置空

> * initList()
>
> ```c
> // 初始化
> Node* initList() {
>     Node* head = (Node*)malloc(sizeof(Node)); // 创建头节点
>     if (head == NULL) {
>         printf("内存分配失败！\n");
>         return NULL; // 分配失败，返回NULL
>     }
>     head->next = NULL; // 初始化头节点的指针域为空
>     return head; // 返回初始化后的链表头指针
> }
> ```

**2.插入-头插法**

1. 先创建**新结点**（堆内存开辟空间），其指针域指向头结点的下一个结点
2. 再让头结点的指针域指向新结点地址

> * insertHead()
>
> ```c
> // 插入-头插法
> int insertHead(Node *head, ElemType e)
> {
>     Node *newNode = (Node *)malloc(sizeof(Node)); // 创建新节点
>     // 异常检查
>     if (newNode == NULL)
>     {
>         printf("内存分配失败！\n");
>         return 0; // 分配失败，返回0
>     }
>     
>     newNode->data = e; // 设置新节点的数据域
>     newNode->next = head->next; // 新节点的指针域指向原链表的第一个节点
>     head->next = newNode; // 头节点的指针域指向新节点
>     return 1; // 插入成功，返回1
> }
> ```

**3.遍历**

1. 创建一个指针表示当前结点，初始为第一个结点，即头结点的指针域
2. 输出当前结点的数据域

> * listElem()
>
> ```c
> // 遍历链表
> void listElem(Node *head)
> {
>     // 异常检查
>     if (head->next == NULL)
>     {
>         printf("链表为空！\n");
>         return; // 如果链表为空，直接返回
>     }
> 
>     // 一般情况
>     Node *current = head->next; // 从第一个节点开始遍历
>     printf("链表中的元素为：\n");
>     while (current != NULL)
>     {
>         printf("%d ", current->data); // 打印当前节点的数据域
>         current = current->next;       // 移动到下一个节点
>     }
>     printf("\n"); // 换行
> }
> ```

**4.插入-尾插法**

1. 创建新的尾结点
2. 设置新结点的数据域
3. 新结点的指针域置空
4. 获取旧的末尾结点地址
5. 旧的末尾结点指针域指向新结点

> * insertTail()
>
> ```c
> // 插入-尾插法
> int insertTail(Node *head, ElemType e)
> {
>     Node *newNode = (Node *)malloc(sizeof(Node)); // 创建新节点
>     // 异常检查
>     if (newNode == NULL)
>     {
>         printf("内存分配失败！\n");
>         return 0; // 分配失败，返回0
>     }
> 
>     newNode->data = e; // 设置新节点的数据域
>     newNode->next = NULL; // 新节点的指针域为空
> 
>     Node *current = head; // 从头节点开始遍历
>     while (current->next != NULL)
>     {
>         current = current->next; // 移动到下一个节点
>     }
>     current->next = newNode; // 将新节点插入到链表的末尾
>     return 1; // 插入成功，返回1
> }
> ```

**5.插入-指定位置插入**

1. 创建新结点，设置数据域
2. 从头开始遍历到指定位置
3. 新结点指针域指向当前结点的下一个结点
4. 当前结点的指针域指向新结点

> * insertValue()
>
> ```c
> // 插入-指定位置插入
> int insertNode(Node *L, int pos, ElemType e)
> {
>     Node *newNode = (Node *)malloc(sizeof(Node)); // 创建新节点
>     // 异常检查
>     if (newNode == NULL)
>     {
>         printf("内存分配失败！\n");
>         return 0; // 分配失败，返回0
>     }
> 
>     newNode->data = e; // 设置新节点的数据域
> 
>     Node *current = L; // 从头节点开始遍历
>     for (int i = 0; i < pos - 1 && current != NULL; i++)
>     {
>         current = current->next; // 移动到下一个节点
>     }
>     if (current == NULL)
>     {
>         printf("插入位置不合法！\n");
>         free(newNode); // 释放新节点的内存
>         return 0;      // 插入失败，返回0
>     }
>     newNode->next = current->next; // 新节点的指针域指向当前节点的下一个节点
>     current->next = newNode;       // 当前节点的指针域指向新节点
>     return 1;                      // 插入成功，返回1
> }
> ```

**6.删除结点**

1. 找到要删除结点的前置结点p
2. 用指针q记录要删除的结点
3. 通过改变p的后继结点实现删除
4. 释放删除结点的空间

> * deleteNode()
>
> ```c
> // 删除-指定位置结点
> int deleteNode(Node *L, int pos)
> {
>     Node *current = L; // 从头节点开始遍历
>     for (int i = 0; i < pos - 1 && current != NULL; i++)
>     {
>         current = current->next; // 移动到下一个节点
>     }
>     if (current == NULL || current->next == NULL)
>     {
>         printf("删除位置不合法！\n");
>         return 0; // 删除失败，返回0
>     }
>     Node *temp = current->next; // 临时保存要删除的节点
>     current->next = temp->next;  // 当前节点的指针域指向要删除节点的下一个节点
>     free(temp);                 // 释放要删除节点的内存
>     return 1;                  // 删除成功，返回1
> }
> ```

**7.释放链表**

1. 指针p指向头结点后的第一个结点
2. 判断指针p是否指向空结点
3. 如果p不为空，用指针q记录指针p的后继结点
4. 释放p指向的结点
5. 指针p和指针p指向同一个结点，循环上面的操作

> * freeList()
>
> ```c
> // 释放链表
> void freeList(Node *L)
> {
>     Node *p = L->next;
>     Node *q;
>     while (p != NULL)
>     {
>         q = p->next; // 保存下一个节点的地址
>         free(p);     // 释放当前节点的内存
>         p = q;       // 移动到下一个节点
>     }
>     L->next = NULL; // 头节点的指针域置为空
> }
> ```

### 2.1.2 应用练习

**1.双指针**

**题1：**

![image-20250408155337970](https://gitee.com/jackqueen/pictures/raw/master/202504081553217.png)

解题思路：**双指针（快慢指针）**

* 快指针先走k步
* 之后快慢双指针一起走
* 直到快指针指向NULL

![image-20250408155516928](https://gitee.com/jackqueen/pictures/raw/master/202504081555119.png)

代码：

```c
// 查找-倒数第k个节点
int findKthFromEnd(Node *list, int k, ElemType *e)
{
    Node *p1 = list->next; // p1指向链表的第一个节点
    Node *p2 = list->next; // 两个指针都指向链表的第一个节点
    for (int i = 0; i < k; i++)
    {
        if (p1 == NULL)
        {
            printf("链表长度不足！\n");
            return 0; // 链表长度不足，返回0
        }
        p1 = p1->next; // p1向前移动k个节点
    }
    while (p1 != NULL)
    {
        p1 = p1->next; // p1和p2同时向前移动
        p2 = p2->next;
    }
    *e = p2->data; // p2指向倒数第k个节点
    return 1;      // 查找成功，返回1
}
```

**题2：**

![image-20250408160653708](https://gitee.com/jackqueen/pictures/raw/master/202504081606511.png)

解题思路：

![image-20250408160748860](https://gitee.com/jackqueen/pictures/raw/master/202504081607418.png)

**题3：**

![image-20250408164504953](https://gitee.com/jackqueen/pictures/raw/master/202504081645079.png)

解题思路：
![image-20250408164531206](https://gitee.com/jackqueen/pictures/raw/master/202504081645632.png)

代码：

```c
// 删除绝对值相同的结点
void removeSameValue(Node *head, int n)
{
    Node *p = head; // p指向当前节点
    int index; // 作为数组下标使用
    int *q = (int *)malloc(sizeof(int) * (n + 1)); // 动态分配数组，存储相同值的节点

    // 初始化数组
    for (int i = 0; i < n + 1; i++)
    {
        *(q + i) = 0; // 将数组元素初始化为0
    }

    while(p->next != NULL)
    {
        index = abs(p->next->data); // 取绝对值作为数组下标
        if (*(q + index) == 0) // 如果该值第一次出现
        {
            *(q + index) = 1; // 标记该值已出现
            p = p->next; // 移动到下一个节点
        }
        else // 如果该值已经出现过
        {
            Node *temp = p->next; // 临时保存要删除的节点
            p->next = temp->next; // 删除当前节点
            free(temp);           // 释放内存
        }
    }
}
```

**2.反转链表**

思路：

使用三个指针

![image-20250408165743925](https://gitee.com/jackqueen/pictures/raw/master/202504081657664.png)

代码：
```c
// 反转链表
void reverseList(Node *head)
{
    Node *first = NULL; // 前一个节点
    Node *second = head->next; // 当前节点
    Node *third = NULL; // 下一个节点

    while (second != NULL)
    {
        third = second->next; // 保存下一个节点
        second->next = first; // 反转当前节点的指针
        first = second;       // 更新前一个节点
        second = third;       // 移动到下一个节点
    }
    head->next = first;		  // 更新头节点的指针域
}
```

**3.删除链表中间节点**

奇数删除中间，偶数删除偏后的中间结点

使用**快慢双指针**

* 慢指针走1步
* 快指针走2步
* 若快指针->next == NULL，慢指针指向中间结点的前置结点

解题思路：

![image-20250408170937244](https://gitee.com/jackqueen/pictures/raw/master/202504081709894.png)

代码：

```c
// 查找-查找中间结点
int findMiddleNode(Node *head, ElemType *e)
{
    Node *slow = head->next; // 慢指针
    Node *fast = head->next; // 快指针

    while (fast != NULL && fast->next != NULL)
    {
        slow = slow->next;       // 慢指针每次移动1步
        fast = fast->next->next; // 快指针每次移动2步
    }
    if (slow != NULL)
    {
        *e = slow->data; // 返回中间节点的数据
        return 1;       // 查找成功，返回1
    }
    return 0; // 查找失败，返回0
}
```

**4.总结**

* 快慢双指针辅助查找，算步数
* 空间换时间，使用带索引的数组辅助操作
* 三指针辅助，单链表只能往前走，反向思维

---

## 2.3 单向循环链表

最后一个结点的指针指向头结点，终止判别条件：p!=L/p!=L->next;

**应用：**

**1.判断是否有环**

* 使用**快慢指针**
* 快指针走两步
* 慢指针走一步
* 若快慢双指针**指向同一个结点**则表示有环

代码：

```c
// 判断是否有环
int hasCycle(Node *head)
{
    if (head == NULL || head->next == NULL)
    {
        return 0; // 链表为空或只有一个节点，没有环
    }

    Node *slow = head; // 慢指针
    Node *fast = head; // 快指针

    while (fast != NULL && fast->next != NULL)
    {
        slow = slow->next;       // 慢指针每次移动1步
        fast = fast->next->next; // 快指针每次移动2步

        if (slow == fast) // 如果相遇，则有环
        {
            return 1; // 有环，返回1
        }
    }
    return 0; // 没有环，返回0
}
```



**2.找环入口**

* 先判断是否有环，找到快慢指针相遇的结点
* 再使用一个指针往前1步走，每走1步计数从1开始count+1，直到再次相遇可知环有多少结点
* 再重置快慢指针到头结点
* 快指针先走count步
* 之后快慢指针一起走
* 直到相遇，相遇结点为入口结点

```c
// 判断环入口
int findCycleEntry(Node *head, Node **entry)
{
    if (head == NULL || head->next == NULL)
    {
        return 0; // 链表为空或只有一个节点，没有环
    }

    Node *slow = head; // 慢指针
    Node *fast = head; // 快指针

    while (fast != NULL && fast->next != NULL)
    {
        slow = slow->next;       // 慢指针每次移动1步
        fast = fast->next->next; // 快指针每次移动2步

        if (slow == fast) // 如果相遇，则有环
        {
            break;
        }
    }

    if (fast == NULL || fast->next == NULL) // 没有环
    {
        return 0; // 返回0
    }

    slow = head; // 重置慢指针到头节点

    while (slow != fast) // 找到环的入口节点
    {
        slow = slow->next; // 慢指针每次移动1步
        fast = fast->next; // 快指针每次移动1步
    }

    *entry = slow; // 返回环的入口节点
    return 1;      // 返回1，表示有环
}
```

---

## 2.4 双向循环链表

存储结构：

```c
typedef int ElemType
    
typedef struct node {
    ElemType data;
    struct node *prev, *next;
}Node;
```

### 2.4.1 基本操作

**1.插入-头插法**

* 先设置插入结点的前驱与后继
* 再设置后继结点的前驱
* 再设置头结点的后继

> * insertHead()
>
> ```c
> // 插入-头插法
> int insertHead(Node *head, ElemType e)
> {
>     Node *newNode = (Node *)malloc(sizeof(Node)); // 创建新节点
>     // 异常检查
>     if (newNode == NULL)
>     {
>         printf("内存分配失败！\n");
>         return 0; // 分配失败，返回0
>     }
>     newNode->data = e;          // 设置新节点的数据域
>     newNode->next = head->next; // 新节点的指针域指向原链表的第一个节点
>     newNode->prev = head;       // 新节点的前驱指针指向头节点
> 
>     if (head->next != NULL) // 如果原链表不为空
>     {
>         head->next->prev = newNode; // 原链表的第一个节点的前驱指针指向新节点
>     }
>     head->next = newNode; // 头节点的指针域指向新节点
> 
>     return 1; // 插入成功，返回1
> }
> ```

**2.插入-尾插法**

> * insertTail()
>
> ```c
> int insertTail(Node *head, ElemType e)
> {
>     Node *newNode = (Node *)malloc(sizeof(Node)); // 创建新节点
>     // 异常检查
>     if (newNode == NULL)
>     {
>         printf("内存分配失败！\n");
>         return 0; // 分配失败，返回0
>     }
>     newNode->data = e; // 设置新节点的数据域
>     newNode->next = NULL; // 新节点的指针域为空
> 
>     Node *current = head; // 从头节点开始遍历
>     while (current->next != NULL) // 找到链表的最后一个节点
>     {
>         current = current->next; // 移动到下一个节点
>     }
>     current->next = newNode; // 最后一个节点的指针域指向新节点
>     newNode->prev = current; // 新节点的前驱指针指向最后一个节点
> 
>     return 1; // 插入成功，返回1
> }
> ```

**3.插入-指定位置插入元素**

> * insertNode()
>
> ```c
> // 插入-指定位置插入
> int insertNode(Node *head, int pos, ElemType e)
> {
>     Node *newNode = (Node *)malloc(sizeof(Node)); // 创建新节点
>     // 异常检查
>     if (newNode == NULL)
>     {
>         printf("内存分配失败！\n");
>         return 0; // 分配失败，返回0
>     }
>     newNode->data = e; // 设置新节点的数据域
> 
>     Node *current = head; // 从头节点开始遍历
>     for (int i = 0; i < pos - 1 && current != NULL; i++)
>     {
>         current = current->next; // 移动到下一个节点
>     }
>     if (current == NULL)
>     {
>         printf("插入位置不合法！\n");
>         free(newNode); // 释放新节点的内存
>         return 0;      // 插入失败，返回0
>     }
>     newNode->next = current->next; // 新节点的指针域指向当前节点的下一个节点
>     newNode->prev = current;       // 新节点的前驱指针指向当前节点
> 
>     if (current->next != NULL) // 如果当前节点的下一个节点不为空
>     {
>         current->next->prev = newNode; // 当前节点的下一个节点的前驱指针指向新节点
>     }
>     current->next = newNode; // 当前节点的指针域指向新节点
> 
>     return 1; // 插入成功，返回1
> }
> ```

**4.删除**

* 下一个结点的前驱指向删除结点的前驱
* 删除结点的前驱指向删除结点的下一个结点
* 释放删除结点

---

## 2.5 顺序表 对比 链表

| 比较项目        | 顺序表                                                       | 链表                                                   |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| 空间-存储空间   | 预先分配，会出现闲置或溢出现象                               | 动态分配，不会出现存储空间闲置或溢出现象               |
| 空间-存储密度   | 不用为表示结点空间的逻辑关系而增加额外的存储，存储密度等于1  | 需要借助指针来体现元素间的逻辑关系，存储密度小于1      |
| 时间-存取元素   | 随机存取，按位置访问元素的时间复杂度为O(1)                   | 顺序存取，按位置访问元素时间复杂度为O(1)               |
| 时间-插入、删除 | 平均移动约表中的一半元素，时间复杂度为O(n)                   | 不需要移动元素，确定插入、删除位置后，时间复杂度为O(1) |
| 适用情况        | 1.表长变化不大，且能事先确定变化的范围<br />2.很少进行插入或删除操作，经常按元素位置序号访问数据元素 | 1.长度变化较大<br />2.频繁进行插入或删除操作           |

# 3.栈和队列

## 3.1 栈-顺序结构

栈：栈是限定仅在表尾进行插入或删除操作的线性表。后进先出的线性表。是限制**插入和删除**操作只能在一个位置进行的表，对栈的基本操作有进栈（push）和出栈（pop）

栈顶：表尾端

栈底：表头端

空栈：不含元素的空表

**栈的顺序存储结构：**

```c
#define MAXSIZE 100
typedef int ElemType; // 定义元素类型为整型

typedef struct
{
    ElemType data[MAXSIZE]; // 数据域，存储栈中的元素
    int top;               // 栈顶指针，指向栈顶元素的下标
} Stack;
```

### 3.1.1 顺序栈的基本操作

**1.初始化**

> * initStack(Stack *s)
>
> ```c
> void initStack(Stack *s)
> {
>     s->top = -1; // 初始化栈顶指针为-1，表示栈为空
> }
> ```

**2.进栈**

> * push()
>
> ```c
> // 进栈
> int push(Stack *s, ElemType e)
> {
>     if (s->top == MAXSIZE - 1) // 检查栈是否已满
>     {
>         printf("栈已满，无法进栈！\n");
>         return 0; // 进栈失败，返回0
>     }
>     
>     s->top++;                // 栈顶指针加1
>     s->data[s->top] = e;    // 将元素e放入栈顶
>     return 1;             // 进栈成功，返回1
> }
> ```

**3.出栈**

> * pop()
> * 顺序栈（顺序表）无法真正实现删除，用覆盖代替删除，只需将栈顶指针-1
>
> ```c
> // 出栈
> ElemType pop(Stack *s, ElemType *e)
> {
>     if (s->top == -1) // 检查栈是否为空
>     {
>         printf("栈为空，无法出栈！\n");
>         return 0; // 出栈失败，返回0
>     }
>     
>     *e = s->data[s->top]; // 将栈顶元素赋值给e
>     s->top--;             // 栈顶指针减1
>     return 1;            // 出栈成功，返回1
> }
> ```

**4.获取栈顶元素**

> * getTop()
>
> ```c
> // 获取栈顶元素
> ElemType getTop(Stack *s, ElemType *e)
> {
>     if (s->top == -1) // 检查栈是否为空
>     {
>         printf("栈为空，无法获取栈顶元素！\n");
>         return 0; // 获取失败，返回0
>     }
>     
>     *e = s->data[s->top]; // 将栈顶元素赋值给e
>     return 1;            // 获取成功，返回1
> }
> ```

**5.动态内存分配**

存储结构：

```c
// 动态内存分配
typedef struct
{
    ElemType *data; // 数据域，存储栈中的元素
    int top;        // 栈顶指针，指向栈顶元素的下标
} DynamicStack;
```

初始化：

> * initDynamicStack()
>
> ```c
> // 动态内存分配初始化
> DynamicStack *initDynamicStack()
> {
>     DynamicStack *s = (DynamicStack *)malloc(sizeof(DynamicStack)); // 创建栈结构体
>     s->data = (ElemType *)malloc(MAXSIZE * sizeof(ElemType)); // 分配栈空间
>     if (s->data == NULL) // 检查内存分配是否成功
>     {
>         printf("内存分配失败！\n");
>         free(s); // 释放栈结构体的内存
>         return NULL; // 分配失败，返回NULL
>     }
>     s->top = -1; // 初始化栈顶指针为-1，表示栈为空
>     return s; // 返回初始化后的栈指针
> }
> ```

---

## 3.2 栈-链式结构

**栈的链式存储结构**

```c
typedef int ElemType; // 定义元素类型为整型

typedef struct stackNode
{
    ElemType data;             // 数据域，存储栈中的元素
    struct stackNode *next;    // 指针域，指向下一个节点
} StackNode;
```

### 3.2.1 链式栈的基本操作

**1.初始化**

> * initStack()
>
> ```c
> StackNode *initStack()
> {
>     StackNode *head = (StackNode *)malloc(sizeof(StackNode)); // 创建栈头节点
>     if (head == NULL)
>     {
>         printf("内存分配失败！\n");
>         return NULL; // 分配失败，返回NULL
>     }
>     head->next = NULL; // 初始化栈头节点的指针域为空
>     return head;       // 返回初始化后的栈头指针
> }
> ```

**2.判断栈是否为空**

> * isEmpty()
>
> ```C
> int isEmpty(StackNode *head)
> {
>     return head->next == NULL; // 如果栈顶指针为空，表示栈为空
> }
> ```

**3.进栈**

栈的链式结构的进栈操作=**头插法**

> * push()
>
> ```c
> int push(StackNode *head, ElemType e)
> {
>     StackNode *newNode = (StackNode *)malloc(sizeof(StackNode));
>     // 异常检查
>     if (newNode == NULL)
>     {
>         printf("内存分配失败！\n");
>         return 0; // 分配失败，返回0
>     }
>     newNode->data = e;          // 设置新节点的数据域
>     newNode->next = head->next; // 新节点的指针域指向原栈顶节点
>     head->next = newNode; // 栈头节点的指针域指向新节点
>     return 1; // 进栈成功，返回1
> }
> ```

**4.出栈**

> * pop()
>
> ```c
> int pop(StackNode *head, ElemType *e)
> {
>     if (isEmpty(head)) // 检查栈是否为空
>     {
>         printf("栈为空，无法出栈！\n");
>         return 0; // 出栈失败，返回0
>     }
>     StackNode *temp = head->next; // 临时节点指向栈顶节点
>     *e = temp->data;              // 将栈顶元素赋值给e
>     head->next = temp->next;      // 栈头节点的指针域指向下一个节点
>     free(temp);                  // 释放临时节点的内存
>     return 1;                    // 出栈成功，返回1
> }
> ```

**5.获取栈顶元素**

> * getTop()
>
> ```c
> int getTop(StackNode *head, ElemType *e)
> {
>     if (isEmpty(head)) // 检查栈是否为空
>     {
>         printf("栈为空，无法获取栈顶元素！\n");
>         return 0; // 获取失败，返回0
>     }
>     *e = head->next->data; // 将栈顶元素赋值给e
>     return 1;             // 获取成功，返回1
> }
> ```

---

## 3.3 队列-顺序存储结构

队列是一种**先进先出**的线性表。它只允许在表的一端进行插入，而在另一端删除元素。

队尾（rear）：允许插入的一端

队头（front）：允许删除的一端

**队列的顺序存储结构：**

```c
#define MAXSIZE 100 // 定义队列的最大容量
typedef int ElemType; // 定义元素类型为整型

typedef struct
{
    ElemType data[MAXSIZE]; // 数据域，存储队列中的元素
    int front;      // 队头指针，指向队头元素的下标
    int rear;       // 队尾指针，指向队尾元素的下标
} Queue;
```

### 3.3.1 基本操作

**1.初始化**

> * initQueue()
>
> ```c
> void initQueue(Queue *q)
> {
>     q->front = 0; // 初始化队头指针为0
>     q->rear = 0;  // 初始化队尾指针为0
> }
> ```

**2.判断队列是否为空**

即判断队头队尾是否相等

> * isEmpty()
>
> ```c
> int isEmpty(Queue *q)
> {
>     return q->front == q->rear; // 如果队头指针等于队尾指针，表示队列为空
> }
> ```

**3.出队**

> * dequeue()
>
> ```c
> ElemType dequeue(Queue *q)
> {
>     if (q->front == q->rear) // 检查队列是否为空
>     {
>         printf("队列为空，无法出队！\n");
>         return -1; // 出队失败，返回-1
>     }
>     ElemType e = q->data[q->front]; // 将队头元素赋值给e
>     q->front++; // 队头指针加1，指向下一个元素
>     return e; // 返回出队的元素
> }
> ```

**4.调整队列**

> * adqueue()
>
> ```c
> int adqueue(Queue *q)
> {
>     if (q->front > 0)
>     {
>         int step = q->front; // 计算需要移动的步数
>         for (int i = q->front; i <= q->rear; i++)
>         {
>             q->data[i - step] = q->data[i]; // 将元素向前移动
>         }
>         q->front = 0; // 重置队头指针
>         q->rear -= step; // 更新队尾指针
>         return 1; // 调整成功，返回1
>     }
> }
> ```

**5.入队**

> * enqueue()
>
> ```c
> int enqueue(Queue *q, ElemType e)
> {
>     if (q->rear >= MAXSIZE)
>     {
>         if(!adqueue(q)) // 调整队列
>         {
>             printf("队列已满，无法入队！\n");
>             return 0; // 入队失败，返回0
>         }
>     }
>     q->data[q->rear] = e; // 将元素e放入队尾
>     q->rear++; // 队尾指针加1
>     return 1; // 入队成功，返回1
> }
> ```

**6.获取队头数据**

> * adqueue()
>
> ```c
> int getFront(Queue *q, ElemType *e)
> {
>     if (isEmpty(q)) // 检查队列是否为空
>     {
>         printf("队列为空，无法获取队头元素！\n");
>         return 0; // 获取失败，返回0
>     }
>     *e = q->data[q->front]; // 将队头元素赋值给e
>     return 1; // 获取成功，返回1
> }
> ```

**7.动态内存分配**

存储结构：

```c
//动态内存分配
typedef struct {
    ElemType *data;
    int front;
    int rear;
}DynamicQueue;
```

初始化：

> * initDynamicQueue()
>
> ```c
> DynamicQueue* initDynamicQueue()
> {
>     DynamicQueue *q = (DynamicQueue*)malloc(sizeof(DynamicQueue));
>     q->data = (ElemType*)malloc(sizeof(ElemType) * MAXSIZE);
>     q->front = 0;
>     q->rear = 0;
>     return q;
> }
> ```

### 3.3.2 队列-循环队列

顺序队列的每次调整需要往前挪动front-0次，效率低，循环队列效率更高。

顺序循环队列存储结构与上一致

### 3.3.3 循环队列基本操作

**1.入队**

**(q->rear + 1) % MAXSIZE == q->front**

> * enCyqueue()
>
> 有个bug在front=1，rear=0时判满
>
> ```c
> int enqueue(Queue *Q, ElemType e)
> {
>     if ((Q->rear + 1) % MAXSIZE == Q->front)
>     {
>         printf("满了\n");
>         return 0;
>     }
>     Q->data[Q->rear + 1] = e;
>     Q->rear = (Q->rear + 1) % MAXSIZE;
>     return 1;
> }
> ```

**2.出队**

> * deCyqueue()
>
> ```c
> // 循环队列的出队
> int deCyqueue(Queue *q, ElemType *e)
> {
>     if (q->front == q->rear) // 检查队列是否为空
>     {
>         printf("队列为空，无法出队！\n");
>         return 0; // 出队失败，返回0
>     }
>     *e = q->data[q->front]; // 将队头元素赋值给e
>     q->front = (q->front + 1) % MAXSIZE; // 队头指针循环移动
>     return 1; // 出队成功，返回1
> }
> ```

---

## 3.4 队列-链式存储结构

**存储结构：**

```c
typedef int ElemType;

typedef struct queueNode
{
    ElemType data;             // 数据域，存储队列中的元素
    struct queueNode *next;    // 指针域，指向下一个节点
} QueueNode;

typedef struct
{
    QueueNode *front;
    QueueNode *rear;
} Queue;
```

### 3.4.1 基本操作

**1.初始化**

> * initqueue()
>
> ```c
> // 初始化
> Queue* initQueue()
> {
>     Queue *q = (Queue*)malloc(sizeof(Queue));
>     QueueNode *node = (QueueNode*)malloc(sizeof(QueueNode));
>     node->data = 0;
>     node->data = NULL;
>     q->front = node;
>     q->rear = node;
>     return q;
> }
> ```

**2.判断队列是否为空**

> isEmpty()
>
> ```c
> int isEmpty(Queue *q)
> {
>     if (q->front == q->rear)
>     {
>         return 1;
>     }
>     else
>     {
>         return 0;
>     }
> }
> ```

**3.入队-尾插法**

> enqueue()
>
> ```c
> void enqueue(Queue *q, ElemType e)
> {
>     QueueNode *node = (QueueNode*)malloc(sizeof(QueueNode));
>     node->data = e;
>     node->next = NULL;
>     q->rear->next = node;
>     q->rear = node;
> }
> ```

**4.出队**

> dequeue()
>
> ```c
> int dequeue(Queue *q, ElemType *e)
> {
>     QueueNode *node = q->front->next;
>     *e = node->data;
>     q->front->next = node->next;
>     if (q->rear == node)
>     {
>         q->rear = q->front;
>     }
>     free(node);
>     return 1;
> }
> ```

---

## 3.5 递归

在函数调用过程中，调用自己本身。

### 3.5.1 斐波那契数列

第1、2项为1，从第3项开始每一项的值为前两项的和

1. 非递归方式

2. 递归方式

   ```c
   int fibonacci(int n)
   {
       if (n == 1 || n == 2) return 1;
       else {
           return fibonacci(n - 1) + fibonacci(n - 2);
       }
   }
   ```

### 3.5.2 后缀表达式

**1.后缀表达式求值**

设置一个数值空栈，遇到数压栈，遇到符号出栈两个操作数，第一个操作数为op2，第二个操作数为op1，进行运算op1 sy op2 = outcome，结果压栈，直到\0

**2.中缀表达式转后缀表达式**

设置一个符号栈，先**用0压栈表示优先级最低**

* 中缀表达式遇到**数直接输出**
* 如果是运算符，判断优先级，如果优先级大于栈顶元素，则压栈。
* 否则将栈顶元素出栈输出，然后将当前运算符压入栈中
* 当左括号在栈外时，属于最高优先级，当左括号在栈里时，属于最低优先级
* 如果是右括号，且栈顶元素不是左括号，**持续出栈并输出**，直到栈顶为左括号出栈结束，最后将左括号也出栈
* 若为\0，则栈中元素依次输出

---

## 3.6 栈对比队列

| 维度     | 栈                                                           | 队列                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 逻辑结构 | 和线性表一样，数据元素之间存在一对一的关系                   | 和线性表一样，数据元素之间存在一对一的关系                   |
| 存储结构 | 顺序存储：存储空间预先分配，可能会出现空间闲置或栈满溢出现象；数据元素个数不能自由扩充<br />链式存储：动态分配，不会出现闲置或栈满溢出现象；数据元素个数可以自由扩充 | 顺序存储（常设计成循环队列形式）：存储空间预先分配，可能会出现空间闲置或队满溢出现象；数据元素个数不能自由扩充<br />链式存储：动态分配，不会出现闲置或队满溢出现象；数据元素个数可以自由扩充 |
| 运算规则 | 插入和删除在表的一端（栈顶完成，后进先出                     | 插入运算在表的一端（队尾）进行，删除运算在表的另一端（队头）进行，先进先出 |

---

---

# 4.树与二叉树

## 4.1 树与二叉树定义

### 4.1.1 树

树是一个或多个结点的有限集合

**基本概念**

* **结点：**树中的一个独立单位
* **结点的度：**结点拥有的子树数称为结点的度
* **树的度：**树内各结点度的最大值
* **叶子：**度为0的结点或终端结点
* **非终端结点：**度不为0的结点
* **双亲和孩子：**结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲
* **层次：**结点的层次从根开始定义，根为第一层，根的孩子为第二层，以此类推

### 4.1.2 树的基本性质

性质一：树中所有**结点数等于所有结点的度数和+1**

性质二：对于度为m的树，**第i层上最多有$m^{i-1}$个结点**

性质三：对于高度为h，度为m的树，最多有$(m^h-1)/(m-1)$个结点

### 4.1.3 二叉树

二叉树（Binary Tree）是n个结点所构成的集合，它或为空树（n=0），或为非空树。

### 4.1.4 二叉树的性质

性质一：二叉树的**第i层最多有$2^{i-1}$个结点**

性质二：**深度为k的二叉树最多有$2^k-1（k≥1）$个结点**

**性质三：**对于任何非空的二叉树T，如果**叶子结点的个数为n0，而度为2的结点数为n2，则n0=n2+1**

### 4.1.5 特殊二叉树

1. 满二叉树：深度为k且含有$2^k-1$个结点的二叉树
2. 完全二叉树：深度为k、有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1到n的结点一一对应时，称之为完全二叉树 
   * 叶子结点只可能在层次最大的两层上出现 
   * 对任一结点，若其右分支的子孙的最大层次为l，则其作分支下的子孙的最大层次必为l或l+1
   * 即-没有左子树，不能有右子树，上一层没有铺满，不能有下一层
   * 具有n个结点的完全二叉树的深度为$log_{2}{n}+1$（向下取整）

---

## 4.2 二叉树的存储结构

**1.顺序存储结构**

除满二叉树和完全二叉树外，其他二叉树顺序存储比较浪费空间

用数组存储

**2.链式存储结构**

设置两个指针域分别指向左右孩子

```c
typedef char ElemType;

typedef struct TreeNode
{
    ElemType data; // 数据域，存储节点的值
    TreeNode *left; // 左子树指针
    TreeNode *right; // 右子树指针
} TreeNode;

typedef TreeNode* BiTree; // 定义二叉树类型为TreeNode指针
```

---

## 4.3 二叉树的基本操作

### 4.3.1 二叉树的遍历

**1.前序遍历**

先访问根结点，再遍历左孩子结点，再遍历右孩子结点

```c
void preOrder(BiTree T) // 先序遍历
{
    if (T == NULL) // 如果树为空，返回
        return;
    printf("%c ", T->data); // 访问根节点
    preOrder(T->left); // 递归遍历左子树
    preOrder(T->right); // 递归遍历右子树
}
```

**2.中序遍历**

先遍历左子树，再访问根结点，再遍历右子树

```c
void inOrder(BiTree T) // 中序遍历
{
    if (T == NULL) // 如果树为空，返回
        return;
    inOrder(T->left); // 递归遍历左子树
    printf("%c ", T->data); // 访问根节点
    inOrder(T->right); // 递归遍历右子树
}
```

**3.后序遍历**

先遍历左子树，再遍历右子树，再访问根结点

```c
void postOrder(BiTree T) // 后序遍历
{
    if (T == NULL) // 如果树为空，返回
        return;
    postOrder(T->left); // 递归遍历左子树
    postOrder(T->right); // 递归遍历右子树
    printf("%c ", T->data); // 访问根节点
}
```

### 4.3.2 二叉树的建立

**按前序的方法建立**

```c
void createBiTree(BiTree *T) // 创建二叉树
{
    char ch;
    scanf("%c", &ch); // 输入节点值
    if (ch == '#') // 如果输入为'#'，表示空节点
        *T = NULL; // 将指针置为NULL
    else
    {
        *T = (BiTree)malloc(sizeof(TreeNode)); // 分配内存
        (*T)->data = ch; // 设置节点值
        createBiTree(&(*T)->left); // 递归创建左子树
        createBiTree(&(*T)->right); // 递归创建右子树
    }
}
```

### 4.3.3 二叉树的遍历-非递归前序遍历

自己定义栈，实现入栈出栈操作，注意栈的先进后出，入栈时右子树先入栈，左子树才能先出

```c
// 非递归前序遍历
void iterPreOrder(Stack *s, BiTree T)
{
    if (T == NULL) // 如果树为空，返回
        return;
    push(s, T); // 将根节点入栈
    while (!isEmpty(s)) // 当栈不为空时
    {
        pop(s, &T); // 出栈
        printf("%c ", T->data); // 访问节点
        if (T->right != NULL) // 如果右子树不为空，将右子树入栈
            push(s, T->right);
        if (T->left != NULL) // 如果左子树不为空，将左子树入栈
            push(s, T->left);
    }
} 
```

### 4.3.4 二叉树遍历性质

1. 已知前序遍历和中序遍历，可以唯一确定一棵二叉树
2. 已知中序遍历和后序遍历，可以唯一确定一棵二叉树
3. 已知**前序**遍历和**后序**遍历，是**不能确定一棵二叉树**

---

## 4.4 线索二叉树

线索化：利用叶子节点的空余空间记录前驱、后继

一棵二叉树中，如果有n个结点，则会存在n+1个空余空间

左右分别新增标记，左0表示左孩子指针，1表示前驱线索；右0表示右孩子指针，1表示后继线索

### 4.4.1 存储结构

```c
typedef char ElemType; // 定义元素类型为字符型

typedef struct ThreadNode
{
    ElemType data;             // 数据域，存储节点的值
    struct ThreadNode *lchild; // 左孩子指针
    struct ThreadNode *rchild; // 右孩子指针
    int ltag;                 // 左标志位，0表示左孩子指针，1表示前驱线索
    int rtag;                 // 右标志位，0表示右孩子指针，1表示后继线索
}ThreadNode;

typedef ThreadNode *ThreadTree; // 定义线索二叉树类型为ThreadNode指针
```

### 4.4.2 中序遍历线索化

**1.开始线索化**

1. 头结点的lchild指向二叉树的根
2. 头结点的rchild指向遍历的最后一个结点
3. 第一个结点的lchild指向头结点
4. 最后一个结点的rchild指向头结点

```c
ThreadNode *pre; // 前驱节点指针
// 开始线索化
void inOrderThreading(ThreadTree *head, ThreadTree T)
{
    *head = (ThreadTree)malloc(sizeof(ThreadNode)); // 创建头节点
    (*head)->ltag = 0; // 左标志位为0，表示左孩子指针
    (*head)->rtag = 1; // 右标志位为1，表示后继线索
    (*head)->rchild = *head; // 头节点的右孩子指向自己

    if (T == NULL) // 如果树为空
    {
        (*head)->lchild = *head; // 头节点的左孩子指向自己
    }
    else
    {
        (*head)->lchild = T; // 头节点的左孩子指向树的根节点
        pre = *head; // 前驱节点指向头节点
        InThread(T); // 中序线索化
        pre->rchild = *head; // 前驱节点的右孩子指向头节点
        pre->rtag = 1; // 设置右标志位为1，表示后继线索

        (*head)->rchild = pre; // 头节点的右孩子指向前驱节点
    }
}
```

**2.线索化函数**

```c
// 中序线索化函数
void InThread(ThreadTree T)
{
    if (T != NULL) // 如果当前节点不为空
    {
        InThread(T->lchild); // 递归线索化左子树
        if (T->lchild == NULL) // 如果左孩子为空
        {
            T->lchild = pre; // 将前驱节点赋值给当前节点的左孩子
            T->ltag = 1;     // 设置左标志位为1，表示前驱线索
        }
        if (pre != NULL && pre->rchild == NULL) // 如果前驱节点不为空且右孩子为空
        {
            pre->rchild = T; // 将当前节点赋值给前驱节点的右孩子
            pre->rtag = 1;   // 设置右标志位为1，表示后继线索
        }
        pre = T; // 更新前驱节点为当前节点
        InThread(T->rchild); // 递归线索化右子树
    }
}
```

### 4.4.3 中序遍历线索二叉树

```c
// 中序遍历线索二叉树
void inOrder(ThreadTree head)
{
    ThreadTree p = head->lchild; // 从头节点的左孩子开始遍历
    while (p != head) // 遍历直到回到头节点
    {
        while (p->ltag == 0) // 如果左标志位为0，表示有左孩子
        {
            p = p->lchild; // 继续向左遍历
        }
        printf("%c ", p->data); // 输出当前节点的值
        while (p->rtag == 1 && p->rchild != head) // 如果右标志位为1，表示有后继线索且不是头节点
        {
            p = p->rchild; // 访问后继节点
            printf("%c ", p->data); // 输出当前节点的值
        }
        p = p->rchild; // 移动到右孩子
    }
}
```

---

## 4.5 哈夫曼树

### 4.5.1 基本概念

**路径：**从树中一个结点到另一个结点之间的分支结构，构成两个结点之间的路径

**路径长度：**路径上的分支数目

**树的路径长度：**从树根到每一个叶结点的路径长度之和

**结点的权：**在实际应用中，给树中的结点赋予代表某种含义的数值

**结点的带权路径长度：**从该结点到树根之间的路径长度与该结点权的乘积

**树的带权路径长度（WPL）：**树中所有叶子结点的带权路径长度之和

**哈夫曼树：**带权路径长度WPL最小的二叉树称为哈夫曼树

*前缀编码：任一字符的编码都不是另一字符编码的前缀*

### 4.5.2 构造哈夫曼树

1. 把带权的叶子结点按小到大顺序排列成有序序列，小放左，大放右
2. 取最小权值的结点作为一个新结点N1的子结点
3. 将结点N1替换刚刚取出的两个结点，并加入有序序列中

![image-20250427180009743](https://gitee.com/jackqueen/pictures/raw/master/202504271800670.png)

4.重复步骤2,3

### 4.5.3 哈夫曼编码

为了解决当年远距离通信的数据传输最优化问题

哈夫曼树中，左孩子路径为0，右孩子路径为1

![image-20250427180950954](https://gitee.com/jackqueen/pictures/raw/master/202504271809784.png)

---

## 4.6 树与二叉树的转换

### 4.6.1 树---转换成-->二叉树

**1.加线**

在所有兄弟结点之间加一条线

**2.去线**

对树中每一个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连接

**3.层次调整**

以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之层次分明。注意**第一个孩子**是二叉树结点的**左孩子**。**兄弟**转过来的孩子是结点的**右孩子**。

### 4.6.2 二叉树---转换成-->树

**1.加线**

若某个结点的左孩子存在，则将这个左孩子的所有右孩子结点都作为此结点的孩子，将该结点与这些右孩子用线连起来

**2.去线**

删除二叉树中所有结点与其右孩子结点的连线

**3.调整**

旋转角度

---

## 4.7 森林与二叉树的转换

### 4.7.1 森林---转换-->二叉树

1. 树转换成二叉树
2. 第一棵二叉树不动，从第二棵树开始，依次把后一颗二叉树的根结点作为前一棵二叉树的根结点的右孩子，然后用线连接起来

### 4.7.2 二叉树转森林

1. 从根结点开始，若右孩子存在，则把右孩子结点的连线删除
2. 二叉树转树

---

## 4.8 层序遍历

使用队列进行记录，先让根结点入队，每次遍历将队中结点的孩子结点入队，每次出队则访问该结点，并且该结点的左右子树不为空，则继续入队

```c
// 层次遍历
void levelOrder(BiTree T)
{
    Queue *q = initQueue(); // 初始化队列
    if (T == NULL)          // 如果树为空，返回
        return;
    enCyqueue(q, T);        // 根节点入队
    while (!isEmpty(q))     // 当队列不为空时
    {
        deCyqueue(q, &T);             // 出队
        printf("%c ", T->data);       // 访问节点
        if (T->left != NULL)          // 如果左子树不为空，将左子树入队
            enCyqueue(q, T->left);
        if (T->right != NULL)         // 如果右子树不为空，将右子树入队
            enCyqueue(q, T->right);
    }
}
```

计算树的深度

```c
// 计算树的深度
int depth(TreeNode *T)
{
    if (T == NULL) // 如果树为空，深度为0
        return 0;

    int depth = 0; // 初始化深度为0
    Queue *q = initQueue(); // 初始化队列
    enCyqueue(q, T); // 根节点入队

    while(!isEmpty(q))
    {
        int count = 0; // 记录当前层的节点数
        count = q->rear - q->front; // 计算当前层的节点数
        while (count > 0) // 遍历当前层的所有节点
        {
            TreeNode *curr;
            deCyqueue(q, &curr); // 出队
            if (curr->left != NULL) // 如果左子树不为空，将左子树入队
                enCyqueue(q, curr->left);
            if (curr->right != NULL) // 如果右子树不为空，将右子树入队
                enCyqueue(q, curr->right);
            count--; // 当前层节点数减1
        }
        depth++; // 深度加1
    }
    return depth; // 返回深度
}
```

---

---

# 5.图

## 5.1 图的基本概念和存储结构

### 5.1.1 基本概念

**1.图的定义：**

图是由顶点的有穷非空集合和顶点之间的边的集合组成的。通常记为G(V,E)，其中G表示一个图，V是图G中顶点的集合，E是边的集合，V(G)和E(G)通常分别表示图G的顶点集合和边集合

注意：不允许没有顶点，但边集可以为空

**2.简单图与多重图：**

限制一：图中不能有从顶点到其自身的边

限制二：同一条边在图中不能出现两次或者两次以上

不满足以上两条限制的图称为多重图

**3.完全图：**

具有最多边数的图

对于一个具有n个顶点的无向完全图，边数量的最大值为n(n-1)/2

对于一个具有n个顶点的有向完全图，边数量的最大值为n(n-1)

**4.路径和路径长度：**

路径：从一个顶点开始，经过一系列的边到达另外一个顶点形成的顶点序列

路径长度：路径上边的条数

回路（环）：起点和终点相同

**5.简单路径：**

简单路径：路径中不出现相同的顶点

简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路

**6.顶点的度：**

度：对于无向图，顶点的度指的是与顶点相关联边的数目

入度：在有向图中，对于顶点v，箭头指向v的边的数目

出度：在有向图中，对于顶点v，从该顶点出发的边的数目

**7.度与边的关系：**

在无向图中，假设具有n个顶点，e条边

* 图中所有顶点度之和等于边数的两倍
* 对于有向图，所有顶点的出度之和等于入度之和，弧的数量相等

**8.连通图：**

连通，在无向图中，如果从顶点V到顶点w有路径，则称顶点v到顶点w是连通的。如果对于图中任意两个顶点都是连通的，则称此图为连通图

**9.连通分量：**

无向图中的极大连通子图称为连通分量

* 连通分量为子图
* 子图为连通图
* 连通子图含有极大顶点数
* 具有极大顶点数的连通子图包含依附于这些顶点的所有边

**10.强连通图：**

有向图中，对于每一对顶点v和w，从v到w和从w到v都有路径，则称该有向图是强连通图

有向图中的极大强连通子图称为有向图的强连通分量

**11.生成树：**

指含有图中全部顶点的极小连通子树

注意：包含所有顶点n，但只有足以构成一棵树的n-1条边

**12.边的权和网：**

在一个图中，每条边可以标注上一个代表某种含义的数值，该数值称为这个边的权值

网：边上带权值的图，也称为权图

### 5.1.2 图的存储结构

**1.邻接矩阵：**

顶点数组：数组存储顶点

邻接矩阵：

* 二维数组表示顶点与顶点之间的边
* 带权值：自己到自己为0，没有关联边的用无穷表示

```c
typedef char VertexType;
typedef int EdgeType;
#define MAXSIZE 100;

typedef struct {
    VertexType vertex[LMAXSIZE];  // 顶点数组
    EdgeType arc[MAXSIZE][MAXSIZE];  // 邻接矩阵
    int vertex_num;  // 顶点数
    int edge_num;  // 边数
}Mat_Grph;
```

**2.邻接表（链表）：**

无向图中，数组存每一个顶点，作为头结点，连接跟该顶点相关联的顶点

缺点：空间浪费

![image-20250514204647700](https://gitee.com/jackqueen/pictures/raw/master/202505142046767.png)

有向图中：表达出边的邻接表

缺点：想知入边比较麻烦（再定义一个入边链接表或使用两条边）

**3.十字链表：**

顶点结构：![image-20250514205158403](https://gitee.com/jackqueen/pictures/raw/master/202505142051683.png)

横向表示出边的关系，纵向表示入边的关系：
![image-20250514205850351](https://gitee.com/jackqueen/pictures/raw/master/202505142058224.png)

**4.邻接多重表：**

解决无向图空间浪费问题

![image-20250514210058473](https://gitee.com/jackqueen/pictures/raw/master/202505142101276.png)

ivex和jvex是某一条边连接的两个顶点的下标

ilink指同连接顶点ivex的下一条边

jlink指同连接顶点jvex的下一条边

![image-20250514210814427](https://gitee.com/jackqueen/pictures/raw/master/202505142108543.png)

---

## 5.2 遍历算法

深度优先~前序遍历，广度优先~层序遍历

### 5.2.1 深度优先算法dfs

```c
void dfs(Mat_Grph G, int i) {
    visited[i] = 1;
    printf("%c\n", G.vertex[i]);
    for (int j = 0; j < G.vertex_num; j++) {
        if (G.arc[i][j] == 1 && visited[j] == 0) {
            dfs(G, j);
        }
    }
}
```

### 5.2.2 广度优先算法bfs

```c
int front = 0;
int rear = 0;
int queue[MAXSIZE];

void bfs(Mat_Grph G) {
    int i = 0;
    visited[i] = 1;
    printf("%C\n", G.vertex[i]);
    queue[rear] = i;
    rear++;
    while(front != rear) {
        i = queue[front];
        front++;
        for (int j = 0; j < G.vertex_num; j++) {
            if (G.arc[i][j] == 1 && visited[j] == 0) {
                visited[j] = 1;
                printf("%C\n", G.vertex[j]);
                queue[rear] = j;
                rear++;
            }
        }
    }
}
```

---

## 5.3 最小生成树算法

最小生成树的顶点数n与边数e之间的关系：n=e+1

kruskal算法针对边，边数少时效率比较高，对稀疏图有优势

prim算法对于边数多的情况效率会好一些

kruskal时间复杂度：$O(e\log{e})$，e是边数

prim时间复杂度为：$O(n^2)$，n是顶点

### 5.3.3 最小生成树-普利姆算法（Prim）

"找最小得到连接"

![image-20250515190002251](https://gitee.com/jackqueen/pictures/raw/master/202505151900911.png) 

```c
#define MAX 0x7fffff

void prim(Mat_Grph* G) {
    int i, j, k;
    int min;
    int weight[MAXSIZE]; // 候选边
    int vex_index[MAXSIZE];  // 值表示出发点，下标表示到达点
    
    // 先从顶点A开始
    weight[0] = 0; // vex_index某点与下标对应点的权重
    vex_index[0] = 0;
    
    for(i = 1; i < G->vertex_num; i++) {
        weight[i] = G->arc[0][i];
        vex_index[i] = 0;
    }
    
    for (int i = 1; i < G->vertex_num; i++) {
        min = MAX;
        j = 0;
        k = 0;
        // 找到最小的，与之连接
        while (j < G->vertex_num) {
            if (weight[j] != 0 && weight[j] < min) {
                min = weight[j];
                k = j;
            }
            j++;
        }
        
        printf("(%d, %d)\n", vex_index[k], k); // 输出连接的两个点的下标
        printf("(%c, %c)\n", G->vertex[vex_index[k]], G->vertex[k]); // 输出连接的两个点的符号
        weight[k] = 0; // 表示该点已经被选，不能成为备选了
        
        // 找新连接结点的待选路径
        for (j = 0; j < G->vertex_num; j++) {
            // 与新结点可连接的边进行比较，有比weight小的就替换
            if (weight[j] != 0 && G->arc[k][j] < weight[j]) {
                weight[j] = G->arc[k][j];
                ver_index[j] = k;
            }
        }
    }
    
    
}
```

### 5.3.4 最小生成树-克鲁斯卡尔（Kruskal）

找最小的边的两顶点进行连接

```c
typedef struct {
    int beigin;
    int end;
    int weight;
}Edge;

int find(int* parent, int index) {
    while(parent[index] > 0) {
        index = parent[index];
    }
    return index;
}

void Kruskal(Mat_Grph G) {
    Edge edges[MAXEDGE];
    int k = 0;
    for(int i = 0; i < G.vertex_num; i++) {
        for (int j = i + 1; j < G.vertex_num; j++) {
            if (G.arc[i][j] < MAX) {
                edges[k].beigin = i;
                edges[k].end = j;
                edges[k].weight = G.arc[i][j];
                k++;
            }
        }
    }
    sortEdges(edges, G.edge_num); // 排序
    int parent[MAXSIZE];  // 下标表示一个顶点，值又表示一个顶点
    for(int i = 0; i < G.vertex_num; i++) {
        parent[i] = 0;
    }
    
    int n, m;
    for (int i = 0; i < G.edge_num; i++) {
        n = find(parent, edges[i].beigin);
        m = find(parent, edges[i].end);
        
        if(n != m) {
            parent[n] = m;
            printf("(%d, %d) %d\n", edges[i].beigin, edges[i].end, edges[i].weight);
            printf("(%c, %c) %d\n", G.vertex[edges[i].begin], G.vertex[edges[i].end], G.vertex[edges[i].weight])
        }
    }
    
}
```

---

## 5.4 最短路径

### 5.4.1 Dijkstra算法

* found[]记录顶点是否已走过
* path[]记录未走过的顶点中距离初始顶点最近
* distance[]记录

```c
void dijkstra(Mat_Graph G, int begin) {
    int found[MAXSIZE]; // 顶点是否已走过
    int path[MAXSIZE]; // 路径
    int distance[MAXSIZE]; // 顶点之间的距离
    for (int i = 0; i < G.vertex_um; i++) {
        found[i] = 0; // 初始化
        path[i] = -1; // 初始化
        distance[i] = G.arc[begin][i]; // 初始化第一个顶点到各顶点的最小距离
    }
    found[begin] = 1;
    distance[begin] = 0;
    int next; // 下一个要观察的顶点
    for (int i = 1; i < G.vertex_num; i++) {
        next = choose(distance, found, G.vertex_num);
        found[next] = 1;
        for (int j = 0; j < G.vertex_num; j++) {
            if (found[j] == 0) {
                if (distance[next] + G.arc[next][j] < distance[j]) {
                    distance[j] = distance[next] + G.arc[next][j]; // 从第一个点到j点最近距离
                    path[j] = next;   // 离下标j的顶点距离最近的点为下标为next的点
                }
            }
        }
    }
    // 从path中找最短路径
    for (int i = 1; i < G.vertex_num; i++) {
        printf("V0 -> v%d : %d\n", i, distance[i]);
        int j = i;
        printf("V%d <-", i);
        while(path[j] != -1) {
            printf("V%d <-", path[j]);
            j = path[j];
        }
        printf("V0\n");
    }
}

// 返回下一次要观察哪一个顶点
int choose(int distance[], int found[], int vertex_num) {
    int min = MAX;
    int minPos = -1;
    for (int i = 0; i < vertex_num; i++) {
        if (distance[i] < min && found[i] == 0) {
            min = distance[i];
            minPos = i;
        }
    }
    return minPos;
}
```

### 5.4.2 Floyd算法

---



### 5.5 拓扑排序

在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先级，这样的有向图为顶点表示活动的网，称为AOV网。

持续寻找入度为0的顶点，然后出栈，入栈，出栈顺序即为拓扑序列。同优先级入栈顺序随意，所以拓扑序列可能不唯一

```c
// 邻接矩阵-图
// ...

// 邻接表边结点结构体
typedef struct EdgeNode {
    int edge_vex; // 结点下标
    struct EdgeNode* next; // 下一个结点
}EdgeNode;

// 邻接表头结点
typedef struct VertexNode {
    int in; // 入度
    VertextType data; // 结点值
    EdgeNode* head; // 链表指针
}VertexNode;

typedef VertextNode Adj_List[MAXSIZE]; // 链表头数组

// 邻接表
typedef struct {
    Adj_List adj_list;
    int vertex_num;
    int edge_num;
}Adj_Graph;

typedef Adj_Graph* Adj_List_Graph;
// 栈
// ...
```

邻接矩阵转换成邻接表

```c
void create_adj_graph(Mat_Graph G, Adj_List_Graph* ALG) {
    EdgeNode* e;
    *ALG = (Adj_List_Graph)malloc(sizeof(Adj_Graph));
    (*ALG)->vertex_num = G.vertex_num;
    (*ALG)->edge_num = G.edge_num;
    
    // 初始化邻接表
    for(int i = 0; i < G.vertex_num; i++) {
        (*ALG)->adj_list[i].in = 0;
        (*ALG)->adj_list[i].data = G.vertex[i];
        (*ALG)->adj_list[i].head = NULL;
    }
    
    // 头插法创建链接表
    for(int i = 0; i < G.vertex_num; i++) {
        for (int j = 0; j < G.vertex_num; j++) {
            if (G.arc[i][j] == 1) {
                e = (EdgeNode*)malloc(sizeof(EdgeNode));
                e->edge_vex = j;
                e->next = (*ALG)->adj_list[i].head;
                (*ALG)->adj_list[i].head = e;
                (*ALG)->adj_list[j].in++;
            }
        }
    }
    
}

void topological_sort(Adj_List_Graph ALG) {
    EdgeNode* e;
    int curr;
    int k;
    for(int i = 0; i < ALG->vertex_num; i++) {
        if (ALG->adj_list[i].in == 0) {
            push(i);
        }
    }
    
    while(is_empty() != 0) {
        curr = pop();
        printf("V%d -> ", ALG->adj_list[curr].data);
        e = ALG->adj_list[curr].head;
        
        while(e != NULL) {
            k = e->edge_vex;
            ALG->adj_list[k].in--;
            if(ALG->adj_list[k].in == 0) {
                push(k);
            }
            e = e->next;
        }
    }
}
```

---

## 5.6 关键路径

在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，称为AOE

etv：事件最早发生的时间（earliest time of vertex）

ltv：事件最晚发生的时间（last time of vertex）

关键路径：etv=ltv的点连起来的路径

```c
void critical_path(Adj_List_Graph ALG) {
    EdgeNode* e;
    int top = -1;
    int top2 = -1;
    int stack[MAXSIZE];
    int stack2[MAXSIZE];
    int etv[MAXSIZE];
    int ltv[MAXSIZE];
    int curr;
    int k;
    for (int i = 0; i < ALG->vertex_num; i++) {
        if (ALG->adj_list[i].in == 0) {
            top++;
            stack[top] = i;
        }
    }
    for (int i = 0； i < ALG->vertex_num; i++) {
        etv[i] = 0;
    }
    while(top != -1) {
        curr = stack[top];
        top--;
        printf("V%d -> ", ALG->adj_list[curr].data);
        
        top2++;
        stack2[top2] = curr;
        
        e = ALG->adj_list[curr].head;
        
        while(e != NULL) {
            k = e->edge_vex;
            ALG->adj_list[k].in--;
            if(ALG->adj_list[k].in == 0) {
                top++;
                stack[top] = k;
            }
            if (etv[curr] + e->weight > etv[k]) {
                etv[k] = etv[curr] + e->weight;
            }
            e = e->next;
        }
    }
    printf("End\n");
    
    printf("etv: ");
    for (int i = 0; i < ALG->vertex_num; i++) {
        printf("%d -> ", etv[i]);
    }
    printf("End\n");
    
    for (int i = 0; i < ALG->vertex_num; i++) {
        ltv[i] = etv[ALG->vertex_num - 1];
    }
    while(top2 != -1) {
        curr = stack2[top2];
        top2--;
        
        e = ALG->adj_list[curr].head;
        while(e != NULL) {
            k = e->edge_vex;
            
            if (ltv[k] - e->weight < ltv[curr]) {
                ltv[curr] = ltv[k] - e->weight;
            }
            e = e->next;
        }
    }
    printf("ltv: ");
    for (int i = 0; i < ALG->vertex_num; i++) {
        printf("%d -> ", ltv[i]);
    }
    printf("End\n");
    
    for (int i = 0; i < ALG->vertex_num; i++) {
        if (etv[i] == ltv[i]) {
            printf("V%d -> ", i);
        }
    }
}
```


# 软件工程基础

## 1.软件工程概述

### 1.1 软件生存周期

1. **可行性分析与项目开发计划**
2. **需求分析**
   * 确定软件系统的功能、性能、数据和界面等要求，从而确定系统的逻辑模型
3. **概要设计**
   * 将各项功能需求转换成需要的体系结构
   * 设计系统的结构，明确软件由哪些模块组成，模块的层次结构、调用关系和功能
   * 设计系统的数据结构和数据库结构
4. **详细设计**
   * 具体描述每个模块完成的功能，把功能描述转变为精确地、结构化的过程描述。
5. **编码**
6. **测试**
   * 设计测试用例
7. **维护**

### 1.2 软件过程

1. <font color=red>能力成熟度模型CMM</font>
2. 能力成熟度模型集成CMMI

---

## 2.软件过程模型

### 2.1 瀑布模型（Waterfall Model）

包括需求分析、设计、编码、测试、运行与维护

规定了由前至后、相互衔接的固定次序

优点：

* 容易理解、管理成本低

缺点：

* 客户必须能够完整、正确和清晰地表达他们的需要

![image-20250423193312223](https://gitee.com/jackqueen/pictures/raw/master/202504231933547.png)

![image-20250423193341100](https://gitee.com/jackqueen/pictures/raw/master/202504231933380.png)

### 2.2 增量模型（Incremental Model）

优点：

* 瀑布模型的所有优点
* 第一个可交付版本所需的成本和时间很少
* 开发由增量表示的小系统所承担风险不大
* 由于很快发布了第一个版本，减少用户需求的变更

缺点：

* 如果没有对用户变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定
* 如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布
* 管理发生的成本、进度和配置的复杂性可能会超出组织的能力

![image-20250423193617297](https://gitee.com/jackqueen/pictures/raw/master/202504231936448.png)

### 2.3 演化模型（Evolutionary Model）

演化模型是迭代的模型，特别适用于对软件需求缺乏准确认识的情况。

**1.原型模型（Prototype Model）**

首先确定用户需求，开发初始模型，然后征求用户对初始原型的改进意见，根据意见修改原型。

* 探索型原型：弄清目标的要求，确定所希望的特性，并探讨多种方案的可行性
* 实验型原型：验证方案或算法的合理性，在大规模开发和实现前，用于考察方案是否合适，规格说明是否可靠等
* 演化型原型：将原型作为目标系统的一部分，通过对原型的多次改进，逐步将原型演化成最终的目标系统

**2.螺旋模型（Spiral Model）**

结合瀑布模型和演化模型，加入风险分析。

分几个螺旋周期，每个螺旋周期分如下四个步骤：

* 制定计划。确定软件的目标，选定实施方案，明确项目开发的限制条件
* 风险分析。分析所选的方案，识别风险，消除风险
* 实施工程。实施软件开发，验证阶段性产品
* 用户评估。评价开发工作，提出修正建议，建立下一个周期的开发计划

![image-20250423195829305](https://gitee.com/jackqueen/pictures/raw/master/202504231958921.png)

### 2.4 喷泉模型（Water Fountain Model）

以用户需求为动力，以对象作为驱动的模型，适用于面向对象的开发方法。

克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。开发过程具有迭代性和无间隙性。

迭代：开发活动常常需要重复多次

无间隙：开发活动之间不存在明显的边界，允许开发活动交叉、迭代进行

优点：

* 可以提高软件项目的开发效率，节省开发时间

缺点：

* 需要大量的开发人员，不利于项目的管理
* 要求严格管理文档，使得审核的难度加大

![image-20250423200434046](https://gitee.com/jackqueen/pictures/raw/master/202504232004311.png)

### 2.5 基于构件的开发模型（Component-based Development Model）

利用预先包装的构件来构造应用系统。本质是演化模型，需要以迭代方式构件软件。

领域工程：

* 构件领域模型、领域基准体系结构和可复用构件库。
* 先进行领域分析，分析该领域中各种应用系统的公共部分或相似部分，构件领域模型和领域基准体系结构
* 最后构件可复用构件

应用系统工程：

* 使用可复用构件组装应用系统
* 先进行应用系统分析，设计应用系统的体系结构，标识应用系统所需要的构件
* 然后再可复用构件库中查找合适的构件（特化或修改）

![image-20250423201025605](https://gitee.com/jackqueen/pictures/raw/master/202504232010968.png)

### 2.6 形式化方法模型（Formal Methods Model）

建立在严格数学基础上的开发方法，主要活动是生成计算机软件形式化的数学规格说明。

### 2.7 统一过程（UP）模型

“用例和风险驱动，以架构为中心，迭代并增量”由UML方法和工具支持。

统一过程定义了4个技术阶段及其制品

1. 起始阶段(Inception Phase)
   * 专注于项目的初创活动，产生的主要工作产品有构想文档、初始用例模型、初始项目术语表、初始业务用例、初始风险评估、项目计划（阶段及迭代）、业务模型，以及一个或多个原型
2. 精化阶段（Elaboration Phase）
   * 在理解最初的领域范围之后进行需求分析和架构演进
   * 主要工作产品有用例模型、补充需求（包括非功能需求）、分析模型、软件体系结构描述、可执行的软件体系结构原型、初步的设计模型、修订的风险列表、项目计划以及初始用户手册
3. 构件阶段（Construction Phase）
   * 关注系统的构件，产生实现模型
   * 主要工作产品有设计模型、软件构建、集成的软件增量、测试计划及步骤、测试用例以及支持文档
4. 移交阶段（Transition Phase）
   * 关注于软件提交方面的工作，产生软件增量
   * 主要工作产品有提交的软件增量、β测试报告和总和用户反馈

### 2.8 敏捷方法（Agile Development）

“尽可能早地、持续地对有价值的软件的交付”

敏捷过程的每一种方法基于一套原则，这些原则实现了敏捷方法所宣称的理念（敏捷宣言）

**1.极限编程（XP）**

轻量级、搞笑、低风险、柔性、可预测的、科学的软件开发方式。由价值观、原则、实践和行为4个部分组成，彼此相互依赖、关联，并通过行为贯穿整个生存周期

**2.水晶法（Crystal）**

认为每一个不同的项目都需要一套不同的策略、约定和方法论

**3.并列争求法（Scrum）**

使用迭代的方法，把每30天一次的迭代成为一个“冲刺”，按需求优先级来实现产品

**4.自适应软件开发（ASD）**

6个基本原则

**5.敏捷统一过程（AUP）**

“大型上连续”“小型上迭代”

每个AUP迭代执行以下活动：

* 建模
* 实现：将模型翻译成源代码
* 测试
* 部署
* 配置及项目管理
* 环境管理

---

## 3.需求分析

### 3.1 软件需求

软件需求是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。

通常包括：功能需求、性能需求、用户或人的因素、环境需求、界面需求、文档需求、数据需求、资源使用需求、安全保密需求、可靠性需求、软件成本消耗与开发进度需求等，并预先估计以后系统可能达到的目标

1. 功能需求。
   * 考虑系统做什么、何时做、何时以及如何修改或升级
2. 性能需求
   * 如存储容量限制、执行速度、响应时间
3. 用户或人的因素
   * 考虑用户的类型
   * 如各种用户对使用计算机的熟练程度、用户错误操作系统的可能性等
4. 环境需求
   * 考虑未来软件应用的环境，包括硬件和软件
   * 硬件设备需求包括机型、外设、接口、地点、分布、湿度等
   * 软件需求包括操作系统、网络、数据库等
5. 界面需求
   * 考虑来自其他系统的输入，到其他系统的输出，对数据格式的特殊规定、数据存储介质的规定
6. 文档需求
   * 考虑需要哪些文档，文档针对哪些读者
7. 数据需求
   * 考虑输入、输出数据的格式，接收、发送数据的频率，数据的准确性和精度，数据流量、数据需保持的时间
8. 资源使用需求
   * 考虑软件运行时需要的数据、其他软件、内存空间等资源
   * 软件开发、维护所需的人力、支撑软件、开发设备等
9. 安全保密需求
   * 考虑是否需要对访问系统加以控制
10. 可靠性要求
    * 考虑系统是否必须检测和隔离错误，出错重启时间等
11. 软件成本消耗和开发进度需求
12. 其他非功能性需求
    * 如采用某种开发模式，确定质量控制标准、里程碑和评审、验收标准、各种质量要求的优先级等，以及可维护性方面的要求

### 3.2 需求分析原则

### 3.3 需求工程

6个阶段

1. 需求获取
2. 需求分析与协商
3. 系统建模
   * 在软件需求分析阶段所创建的模型，要着重于描述系统要做什么，而不是如何去做，模型不涉及软件的视线细节
   * 常用分析方法有：面向数据流的结构化分析方法（SA）、面向对象的分析方法（OOA）
4. 需求规约
   * 分析任务的最重产物
   * 包括：引言、信息描述、功能描述、行为描述、检验标准、参考书录、附录
5. 需求验证
6. 需求管理

---

## 4.系统设计

“做什么”转换为“怎么做”

主要内容包括新系统的总体结构设计、代码设计、输出设计、输入设计、处理过程设计、数据存储设计、用户界面设计、安全控制设计等

两种设计方法：

* 面向数据流的结构化设计方法
* 面向对象的分析方法

### 4.1 概要设计

1. 设计软件系统总体结构
   * 将一个复杂的系统按功能划分成模块
   * 确定每个模块的功能
   * 确定模块之间的调用关系
   * 确定模块之间的结构，即模块之间传递的信息
   * 评价模块结构的质量
2. 数据结构及数据库设计
   * 数据结构的设计，细化数据的结构特性，概要设计阶段宜使用抽象的数据类型
   * 数据库的设计：
     1. 概念设计：自底向上的方法，从用户角度进行视图设计（E-R模型）
     2. 逻辑设计
     3. 物理设计
   * 编写概要设计文档
   * 审评

### 4.2 详细设计

1. 对每个模块进行详细的算法设计
2. 设计模块内的数据结构
3. 对数据库进行物理设计
4. 其他设计，如代码设计、输入/输出格式设计、用户界面设计
5. 详细设计说明书
6. 评审

---

## 5.系统测试

### 5.1 系统测试与调试

1. 信息系统测试应包括软件测试、硬件测试和网络测试

### 5.2 传统软件的测试策略

软件测试四步：

**1.单元测试（模块测试）**

单元测试内容：

* 模块接口
  * 测试模块输入参数和形参在个数、属性、单位上是否一致
  * 调用其他模块时，实参形参是否一致
  * 调用标准函数时，参数是否一致
  * 全局变量在各模块中的定义和用法是否一致
  * 输入是否改变形参
  * 开/关语句是否正确
  * 规定的I/O格式是否一致
  * 使用文件前是否打开文件或使用之后是否关闭文件
* 局部数据结构
  * 变量说明是否合适
  * 是否使用了尚未赋值或尚未初始化的变量
  * 变量的初始值或默认值是否正确
  * 变量名是否有错
* 重要的执行路径
  * 计算错误，如运算优先次序、精度不够
  * 比较和控制流的错误
* 出错处理
* 边界条件

单元测试过程：

对每个模块进行测试时，需要开发两种模块

* 驱动模块。相当于一个主程序，接收测试例子的数据，将这些数据送到测试模块，输出测试结果
* 桩模块（存根模块）。用来替代测试模块中所调用的子模块，内部可进行少量的数据处理，目的是为了检验入口，输出调用和返回的信息

**2.集成测试**

两种方法

* 非增量集成：分别测试各个模块，再把这些模块组合起来进行成体测试
* 增量集成：以小增量的方式逐步进行构造和测试

增量集成策略：

1. 自顶向下集成测试
   * 从主控模块（主程序）开始，沿着控制层逐步向下，深度或广度优先
2. 自底向上集成测试
   * 从原子模块开始构造和测试，没必要使用桩模块
3. 回归测试
4. 冒烟测试
   * 将已经装换为代码的软件构件集成到构建中
   * 设计一系列测试以暴露影响构建正确的完成其功能的错误
   * 每天将该构建与其他构建及整个软件产品集成起来进行冒烟测试，可自顶向下，也可自底向上

**3.确认测试**

始于集成测试的结束，已经完成单个构件，软件已组装成完整的软件包，且接口错误已被发现和改正。测试集中于用户可见的动作和用户可识别的系统输出

1. 确认测试基准
2. 配置评审
3. **α测试与β测试**
   * α测试是由**有代表性的最终用户在开发者的场所进行**，软件在自然的环境下使用，开发者站在用户的后面观看，并记录错误和使用问题。α测试在受控的环境下进行
   * β测试在一个或多个最终用户场所执行。与α测试不同，**开发者通常不在场**，β测试是在不被开发者控制的环境下软件的“现场”应用。最终用户记录测试过程中遇见的所有问题，并定期报告给开发者。接到β测试的问题报告之后，开发人员对软件进行修改，然后准备向最终用户发布软件产品

**4.系统测试**

将已经确定的软件、计算机硬件、外设和网络等其他因素结合在一起，进行信息系统的各种集成测试和确认测试

1. 恢复测试
   * 处理错误绝不能使整个系统功能都停止
   * 通过各种方式强制让系统发生故障，并验证能否按照要求从故障中恢复过来，并在约定的时间内开始事务处理，而且不对系统造成任何伤害
   * 如果系统的恢复是自动的，需要重新验证初始化、检查点和数据恢复等是否正确；如果恢复需要人工干预，就要对恢复的平均时间进行评估判断它是否在允许的范围内
2. 安全性测试
   * 验证建立在系统内的保护机制是否能够实际保护系统不受非法入侵
   * 设计准则是使非法入侵者所花费的代价大于攻破系统之后获取信息的价值
3. 压力测试
   * 以非正常的数量、频率或容量等方式执行系统
4. 性能测试
   * 用来测试软件在集成环境下的运行性能
   * 经常与压力测试一起进行
5. 部署测试（配置测试）
   * 在软件将要运行的每一种环境中测试软件

### 5.3 测试面向对象软件

1. 单元测试
   * 面向对象软件中单元的概念发生了变化，封装的类常是单元测试的重点
2. 集成测试
   * 基于线程的测试，对响应系统的一个输入或事件所需的一组类进行集成，每个线程单独地集成和测试，并应用回归测试以确保没有产生副作用
   * 基于使用的测试

### 5.4 测试Web应用

1.质量维度

* 内容。在语法及语义层对内容进行评估
* 功能
* 结构
* 可用性
* 导航性
* 性能
* 兼容性
* 安全性

2.WebApp测试策略

采用所有软件测试使用的基本原理，并建议使用面向对象系统实用的策略和战术

* 对内容模型进行评审
* 对接口模型进行评审
* 评审设计模型，发现导航错误
* 测试用户界面
* 对功能构件进行单元测试
* 测试贯穿体系结构的导航
* 不同环境下配置实现WebApp，测试兼容性
* 进行安全性测试
* 进行性能测试
* 通过可监控的最终用户群测试

### 5.5 测试方法

将特定的测试方法和测试用例设计放在一系列的测试步骤中

1. 静态测试。指被测试程序不在机器上运行，采用人工检测和计算机辅助静态分析
2. 动态测试。指运行程序发现错误。可采用黑盒测试法和白盒测试法

**黑盒测试（功能测试）：**不考虑软件内部结构和特性，测试软件的外部特征

* 等价类划分
  * 将程序的输入域划分为若干等价类，然后从每个等价类中选取一个代表性数据作为测试用例
* 边界值分析
* 错误推测
* 因果图
  * 从自然语言描述的程序规格说明中找出因（输入条件）和果（输出或程序状态的改变），通过因果图转换为判定表

**白盒测试（结构测试）：**根据程序的内部结构和逻辑来设计测试用例，对程序的路径和过程进行测试

* 逻辑覆盖
  * 语句覆盖。选择足够的测试数据，使被测试程序中的每条语句至少执行一次
  * 判定覆盖。使得被测程序中每个判定表达式至少获得一次“真”值和“假”值
  * 条件覆盖。使得每一判定语句中每个逻辑条件的各种可能的值至少满足一次
  * 判定/条件覆盖。使得判定中每个条件的所有可能取值（真/假）至少出现一次，且每个判定本身的判定结果（真/假）也至少出现一次
  * 条件组合覆盖。使得每个判定中条件的各种可能值的组合都至少出现一次
  * 路径覆盖。覆盖测试程序中所有可能的路径
* 循环覆盖。执行足够的测试用例，使得循环中的每个条件都得到验证
* 基本路径测试。在程序控制流图的基础上通过分析控制流图的环路复杂性，导出基本可执行路径集合

白盒测试的原则：

* 程序模块中所有独立路径至少执行一次
* 所有逻辑判断中，取“真”和取“假”的两种情况至少都能执行一次
* 每个循环都应在边界条件和一般条件下各执行一次
* 测试程序内部数据结构的有效性等

### 5.6 调试

发生在测试之后，根据测试时所发现的错误找出原因和具体位置，进行改正

1. 调试过程
2. 调试方法
   * 试探法
   * 回溯法
   * 对分查找法
   * 归纳法
   * 演绎法

---

## 6.运行和维护知识

### 6.1 系统转换

系统试运行：

* 对系统进行初始化、输入各种原始数据记录
* 记录系统运行的数据和状况
* 核对新系统输出和旧系统输出的结果
* 对实际系统的输入方式进行考察（方便、效率、安全性等）
* 对系统实际运行、响应速度（包括运算速度、传输速度、查询和输出速度等）进行实际测试

试运行成功后可以在新系统和旧系统之间转换：

* 直接转换。在确定新系统运行无误时立刻启用新系统，终止旧系统运行
* 并行转换。新旧系统并行工作一段时间，经过一段时间的考验后，新系统正是替代旧系统
* 分段转换。新系统全部正式运行前，一部分一部分替代旧系统，没有正式运行的部分在模拟环境中继续试运行。要求子系统之间有一定独立性

### 6.2 系统维护概述

**1.系统可维护性**

系统可维护性评价指标：

1. 可理解性。指别人能理解系统的结构、界面、功能和内部过程的难易程度
2. 可测试性
3. 可修改性

维护与软件文档：文档是可维护性的决定因素

软件文档的修改

**2.系统维护的内容及类型**

主要包括硬件维护、软件维护和数据维护

* 硬件维护
* 软件维护
  * 正确性维护
  * 适应性维护
  * 完善性维护
  * 预防性维护
* 数据维护
  * 主要负责数据库的安全性和完整性以及进行并发性控制

**3.系统维护的管理和步骤**

### 6.3 系统评价

**1.系统评价**

广义：系统开发的一开始到结束的每一阶段都进行评价

狭义：系统建成并投入运行之后进行全面、综合的评价

* 立项评价：指信息系统方案在系统开发前的预评价，即系统规划阶段中的可行性评价
  * 目的：决定是否立项进行开发
  * 内容：分析当前开发新系统的条件是否具备，明确新系统目标实现的重要性和可行性
* 中期评价：一是指方案实施过程中因外部环境出现重大变化需要对项目方案进行重新评估决定继续执行还是终止该方案；另一种是指在信息系统开发正常的情况下，对系统设计、系统分析、系统实施的阶段性成果进行评估
* 结项评价：指信息系统正式运行后，为了解系统是否达到预期的目的和要求而对系统运行的实际效果进行的综合评价

**2.系统评价的指标**

* 从信息系统组成出发，按照运行效果和用户需求（人）、系统质量和技术条件（机）两条线索构造指标
* 从信息系统的评价对象出发
* 从经济学角度出发，分别按系统成本、系统效益和财务指标3条线索建立指标

---

## 7.软件项目管理

### 7.1 软件项目管理涉及的范围**

1. 人员
2. 产品
3. 过程
4. 项目

### 7.2 软件项目估算**

估算方法：

* 自顶向下估算法
* 自底向上估算法
* 差别估算法
* 其他估算法
  * 专家估算法
  * 类推估算法
  * 算式估算法

COCOMO估算模型：

* 基本COCOMO模型
* 中级COCOMO模型
* 详细COCOMO模型

COCOMOII模型

* 应用组装模型
  * 用户界面的原型开发、对软件和系统交互的考虑、性能的评估及技术成熟度的评价
* 早期设计阶段模型
  * 在需求已经稳定并且基本的软件体系机构已经建立时使用
* 体系结构阶段模型

Putnam估算模型

### 7.3 进度管理


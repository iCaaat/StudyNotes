# 初识Java

## 1.Java SE ME EE

### Java SE

java语言的标准版，用于桌面应用的开发，是其他两个版本的基础。

### Java ME（淘汰）

java语言的（小型版），用于嵌入式电子设备或小型移动设备。

### Java EE（顶尖）

java语言的（企业版），用于web方向的网站开发。

企业级应用开发（服务器开发），比如微服务，SpringCloud。

---

## 2.JDK和JRE

### JDK-Java开发工具包（Java Development Kit）

JDK包括JVM(java虚拟机)、核心类库、开发工具（包括Javac、java等）

### JRE-Java运行环境包（Java Runtime Environment）

JRE中含JVM、核心类库、运行工具

---

# Java入门

## 1.注释

```java
// 行注释

/* 
多行注释
*/

/**
 * 
 * 文档注释
 */
```

* 文档注释详细在后文。

---

## 2.关键字

* 关键字字母**全部小写**
* 如`public`、`class`等
* class用于定义一个类

---

## 3.字面量

告诉程序员：数据在程序中的书写格式

| 字面量类型 | 说明                 | 举例         |
| ---------- | -------------------- | ------------ |
| 整数类型   | 不带小数的数字       | 666，-88     |
| 小数类型   | 带小数的数字         | 13.14        |
| 字符串类型 | 用双引号括起来的内容 | "HelloWorld" |
| 字符类型   | 用单引号括起来的内容 | 'A'，'0'     |
| 布尔类型   | 布尔值，表示真假     | true，false  |
| 空类型     | 一个特殊的值，空值   | 值是：null   |

**特殊'字符'类型-转义字符**：

* `\t`：制表符，在打印的时候，把**前面**字符串的长度补齐**到**8，或者8的整数倍。最少补1个空格，最多补8个空格

---

## 4.变量

存储经常发生变化的数据

格式：

* *数据类型 变量名 = 数据值;*
* *数据类型 变量名;*

数据类型：如`int`，`double`

**注意**：

* 一条语句中可定义多个变量，用逗号隔开，如：

```java
int d = 100, e = 200, f = 300;
```

* 变量在使用前必须赋值

---

## 5.标识符

给类、方法、变量等起的名字

### 5.1 阿里巴巴命名规范

**标识符命名规则 - 硬性要求**：

* 由数字、字母、下划线(_)和美元符($)组成
* 不能以数字开头
* 不能是关键字
* 区分大小写

**标识符命名规则 - 软性建议**：

* 小驼峰命名法：**方法、变量**
  * 规范1：标识符是一个单词的时候，全部小写
  * 范例1：`name`
  * 规范2：标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写
  * 范例2：`firstName`
* 大驼峰命名法：**类名**
  * 规范1：标识符是一个单词的时候，首字母大写
  * 范例1：`Student`
  * 规范2：标识符由多个单词组成的时候，每个单词的首字母大写
  * 范例2：`GoodStudent`
* 见名知意

---

# Java基础

## 1.数据类型

Java的数据类型分为基本数据类型和引用数据类型。

区别在于内存分配不一样

### 1.1 基本数据类型

在栈内存，变量里存储的是真实的数据

* 数据值存储在自己的空间中
* 赋值给其他变量，也是赋的真实的值

| 数据类型 | 关键字  | 取值范围                                         | 内存占用 |
| -------- | ------- | ------------------------------------------------ | -------- |
| 整数     | byte    | -128~127                                         | 1        |
|          | short   | -32768~32768                                     | 2        |
|          | int     | -2147483648~2147483647（10位）                   | 4        |
|          | long    | -9223372036854775808~9223372036854775807（19位） | 8        |
| 浮点数   | float   | -3.401298e-38到3.402823e+38                      | 4        |
|          | double  | -4.9000000e-324到1.797693e+308                   | 8        |
| 字符     | char    | 0-65535                                          | 2        |
| 布尔     | boolean | true,false                                       | 1        |

* 基本数据类型为四类八种

* 如果要定义`long`类型的整数，需要在数据后面加一个**l或者L**，建议使用L。比如：

  ```java
  long l = 9999999999L;
  ```

  如果要定义`float`类型的小数，需要在数据后面加一个**f或者F**，建议使用F。比如：

  ```java
  float f = 10.1F;
  ```

* 整数与小数的取值范围大小关系`double > float > long > short > int > shuot > byte`

### 1.2 引用数据类型

在堆内存开辟空间，变量里存储的是其他空间的地址值，而非真实数据，一般都由 `new` 关键字所创建

* 数据是存储在其他空间中，自己空间中存储的是地址值
* 赋值给其他对象，赋的是地址值，如果其他对象对该空间进行修改，调用该对象获得的也是修改之后的值

---

## 2.键盘录入

Java已经写好一个类叫`Scanner`，这个类可以接收键盘输入的数字。

使用步骤：

1. 导包

   ```java
   import java.util.Scanner;
   ```

2. 创建对象

   ```java
   Scanner sc = new Scanner(System.in);
   ```

3. 接收数据

   ```java
   int i = sc.nextInt();
   ```

---

## 3.运算符

运算符：对字面量或者变量进行操作的符号

表达式：用运算符把字面量或者变量连接起来，符合java语法的式子

### 3.1 算数运算符

算数运算符有`+ - * / %`等

* 在整数时`+ - *`与数学运算一致，`/ %`有所区别
* 除法运算中，两个整数相除，结果仍然是整数，丢弃小数部分，如果希望得到小数结果，其中一个数据必须是小数
* `%` 求余运算，结果符号与被除数一致
* 如果有小数参与，结果可能有不精确的，具体原因请看java进阶的小数存储方式。

* 数字进行运算时，数据类型不一样不能运算，需要转成一样的才能运算

**隐式转换**（自动类型提升）：

* 取值范围小的数值 自动提升-> 取值范围大的数值
* `byte -> short -> int -> long -> float -> double`
* `byte`、`short`、`char`三种类型的数据在运算时都会直接提升为`int`，然后再进行计算

**强制转换**：

* 取值范围大的 -> 取值范围小的，不允许直接赋值，否则需要做强制转换

* 格式： *目标数据类型 变量名 = (目标数据类型)被强转的数据;*

* 可能会导致数据发生错误

* 示例：

  ```java
  double a = 12.3;
  int b = (int)a;
  ```

**字符串中的`+`**：

当`+`操作中出现字符串时，这个`+`是字符串连接符，而不是算数运算符。会将前后的数据进行拼接，并产生一个新的字符串。示例：

```java
"123" + 123 // "123123"
```

连续进行`+`操作，会从左到右逐个执行。示例：

```java
1 + 99 + "年黑马"  // "100年黑马"
```

**字符(char)中的`+`**：

当`+`操作中出现字符时，会对照ASCII码表转换为int再参与运算

### 3.2 自增自减运算符

**基本用法**：

| 符号 | 作用 | 说明      |
| ---- | ---- | --------- |
| `++` | 加   | 变量值加1 |
| `--` | 减   | 变量值减1 |

`a++`：先用后加-先参与运算再自增

`++a`：先加后用-先自增后参与运算

### 3.3 赋值运算符

| 符号 | 作用     | 说明                 |
| ---- | -------- | -------------------- |
| `=`  | 赋值     |                      |
| `+=` | 加后赋值 | `a+=b` = `a = a + b` |
| `-=` | 减后赋值 |                      |
| `*=` | 乘后赋值 |                      |
| `/=` | 除后赋值 |                      |
| `%=` | 余后赋值 |                      |

* 注意：底层包含**强制类型转换**，比如

  ```java
  short s = 1;
  s += 1;  // 等同s1 = (short) (s1 + 1);
  ```

### 3.4 关系运算符

| 符号 | 说明                            |
| ---- | ------------------------------- |
| `==` | 判断相等，相等true，不相等false |
| `!=` | 判断不相等                      |
| `>`  | 判断大于                        |
| `>=` | 判断大于等于                    |
| `<`  | 判断小于                        |
| `<=` | 判断小于等于                    |

* 关系运算符的结果都是**boolean**类型

### 3.5 逻辑运算符

| 符号 | 作用     | 说明                                  |
| ---- | -------- | ------------------------------------- |
| `&`  | 逻辑与   | 并且，两边真才为真                    |
| `|`  | 逻辑或   | 或者，两边假才为假                    |
| `^`  | 逻辑异或 | 一边真边假为true，两边真两边假为false |
| `!`  | 逻辑非   | 取反                                  |

**短路逻辑运算符**：

| 符号 | 作用   | 说明                             |
| ---- | ------ | -------------------------------- |
| `&&` | 短路与 | 若前一个为假，则为假，不继续判断 |
| `||` | 短路或 | 若前一个为真，则为真，不继续判断 |

* 左边能确定整个表达式的结果，则右边不会执行，提高运行效率
* 最常用的逻辑运算符：`&& || !`

### 3.6 三元运算符

格式：*关系表达式 ? 表达式1 : 表达式2;*

示例：求两个数的最大值

```java
a > b ? a : b;
```

* 结果一定要被使用

### 3.7 运算符优先级

只需记住`()`中的优先级大于其他所有

---

## 4.原码/反码/补码

正数的原码、反码、补码都是一样的

### 4.1 原码

十进制数据的二进制表现形式，最左边的是符号位，0为正，1为负

最大值：01111111 -> 127

最小值：11111111 -> -127

利用原码对正数进行计算不会有问题。

**原码的弊端**：

* **负数**计算有问题，实际计算的结果与预期**结果是反的**

  10000000 -> -0

  —— +1 = 10000001 ? 正确值：+1 实际值：-1

### 4.2 反码

为了**解决原码不能计算负数**的问题而出现的。

**计算规则**：正数的反码不变，负数的反码在原码的基础上，符号位不变，数值取反

例：

* -4 --原码-> 10000100 --反码-> 11111011(反)

  —— +1 = 11111100(反) = -3

  —— -1 = 11111010(反) = -5

**反码的弊端**：

**"跨0"计算会出现1的误差**，如

* -0 --原码-> 10000000 --反码-> 11111111(反)

  —— +1 = 00000000(反) = +0 正确值：1

* -2 --原码-> 10000010 --反码-> 11111101(反)

  —— +3 = 00000000(反) = +0 正确值：1

### 4.3 补码

正数补码=原码=反码不变，负数补码=反码+1。

这样 -0 和 +0 补码都是00000000，正负数的计算也不再出错

注意：

* 补码中 10000000 的十进制数为 **-128**，该数没有原码和补码
* 计算机内存中存储整数都以补码形式

> ## 💡二进制只是形式，关键在于解释规则
>
> | 数据类型        | 存储规则 / 编码方式                        | 举例              |
> | --------------- | ------------------------------------------ | ----------------- |
> | **整数**        | 原码 / 反码 / **补码**（实际使用的是补码） | int, long         |
> | **浮点数**      | **IEEE 754 标准**（符号 + 指数 + 尾数）    | float, double     |
> | **字符 / 文本** | 字符编码（ASCII、UTF-8、UTF-16 等）        | 'A', '你'         |
> | **图像**        | 图像格式编码（BMP、JPEG、PNG…）            | 灰度图、RGB 图    |
> | **音频**        | 音频格式编码（WAV、MP3、FLAC…）            | 采样率、位深度    |
> | **视频**        | 视频编解码格式（H.264、VP9、AV1…）         | MP4 文件          |
> | **结构化数据**  | 复合结构（比如数据库、对象序列化）         | JSON、protobuf 等 |
>
> > “计算机只会存储二进制，但我们赋予这些二进制**意义**的方式，就是各种编码规则。”

### 4.4 其他运算符

| 运算符 | 含义                                                 | 运算规则                                        |
| ------ | ---------------------------------------------------- | ----------------------------------------------- |
| `&`    | 按位与                                               | 1&1=1,1&0=0,0&0=0                               |
| `|`    | 按位或                                               | 1\|1=1,1\|0=1,0\|0=0                            |
| `<<`   | 左移                                                 | `<< 1`左移1位，右边补0，相当于 **乘以 2**       |
| `>>`   | 右移（保留符号），左边补符号位（正数补 0，负数补 1） | `>> 1`右移1位，相当于**除以2(向下取整)**        |
| `>>>`  | 右移（不保留符号），左边补0                          | `>>> 1`右移1位，相当于去符号**除以2(向下取整)** |

`&`用于不同类型的区别

| 操作符 | 用于类型                     | 含义             | 是否短路 | 返回类型 |
| ------ | ---------------------------- | ---------------- | -------- | -------- |
| `&`    | int, long, short, byte, char | 按位与           | 否       | 数值型   |
| `&`    | boolean                      | 逻辑与（非短路） | 否       | boolean  |
| `&&`   | boolean                      | 逻辑与（短路）   | 是       | boolean  |

---

## 5.流程控制语句

### 5.1 分支结构

**if**：

```java
if (条件) {
    语句;
}
```

或

```java
if (条件2) {
    语句1；
} else {
    语句2;
}
```

或

```java
if (条件1) {
    语句1；
} else if (条件2) {
    语句2;
} else {
    语句3;
}
```

* 若语句只有一句，{}可不写，但阿里规范建议不管几句 **不省略{}**

* 第三种格式一般用于范围的判断

* 规范建议：条件为布尔类型，不用`==`

* 示例：

  ```java
  boolean flag = false;
  if(flag) {
      System.out.println("flag的值:" + flag);
  }  
  ```

**switch**：

一般用于列举，任选其一

```java
switch(表达式) {
    case 值1:
        语句1;
        break;
    case 值2:
        语句2;
        break;
    ...
    default:
        语句n;
        break;
}
```

* 表达式：将要匹配的值(`byte`、`short`、`int`、`char`)，jdk5以后可以是`枚举`，jdk7以后可以是`String`。
* `case`：后面接要与表达式进行比较的值（被匹配值）。
* `break`：表示中断，用来结束switch语句。
* `default`：表示所有情况都不匹配时，执行该处语句。可以省略，也可更换位置。
* `case`后面的值只能是字面量，不能是变量，且不能重复。

**jdk12+的新特性**：用{}简化`break`

```java
int number = 1;
switch (number) {
        case 1 -> {
            System.out.println("一");
        }
        case 2 -> {
            System.out.println("二");
        }
        ...
        default -> {
            System.out.println("没有这种选项");
        }
}
```

若`{}`中只有一行代码，则可以省略

```java
int number = 1;
switch (number) {
        case 1 -> System.out.println("一");
        case 2 -> System.out.println("二");
        ...
        default -> System.out.println("没有这种选项");
}
```

### 5.2 循环结构

**for循环**:

```java
for (初始化语句; 条件判断语句; 条件控制语句) {
    循环体语句；
}
```

* 初始化语句只执行一次
* 每次循环先执行条件判断语句，若为true，继续执行，若为false，退出循环
* 条件控制语句执行在循环体语句之后

**while循环**：

```java
初始化语句;
while (条件判断语句) {
    循环体语句;
    条件控制语句;
}
```

* 先执行初始化条件语句和条件判断语句，条件判断语句为true，则继续执行，若为false，退出循环。

**for循环与while循环对比**：

相同点：运行规则是一样的

区别：

* for循环：知道**循环次数**或者**循环的范围**
* while循环：不知道循环的次数和范围，但知道循环的**结束条件**。

**do..while循环**：

```java
初始化语句;
do {
    循环体语句;
    条件控制语句;
} while (条件判断语句);
```

**跳转控制语句**：

`continue`：结束本次循环，跳转到下一次循环。

`break`：结束整个循环。

> ## 获取随机数Random
>
> ### 1.导包
>
> ```java
> import java.util.Random;
> ```
>
> ### 2.创建对象
>
> ```java
> Random r = new Random();
> ```
>
> ### 3.生成随机数
>
> ```java
> int number = r.nextInt(随机数的范围);
> ```
>
> * 生成的随机数范围在[0, 输入的数)之间

---

## 6.数组

### 6.1 定义和初始化

数组指的是一种容器，用来存储同种数据类型的多个值。需结合隐式转换考虑。

定义：

```java
// 常用
数据类型 [] 数组名;
int [] array;
```

```java
数据类型 数组名[];
int array[];
```

初始化：

就是在内存中，为数组开辟空间，并将数据存入容器中的过程。

静态初始化：

```java
数据类型 [] 数组名 = new 数据类型 [] {元素1, 元素2...};
int [] array = new int[] {11, 22, 33};
double [] array2 = new double[] {11, 22, 33};
```

简化（常用）：

```java
数据类型 [] 数组名 = {元素1, 元素2, 元素3...};
int [] array = {11, 22, 33};
double [] array2 = {11.1, 22.2, 33.3}
```

**数组一旦创建并初始化，长度就被固定、不能发生变化**

> ## 扩展
>
> 直接打印数组名得到的是地址值
>
> ```shell
> [I@4eec7777
> [D@3b07d329
> ```
>
> * `[`：表示当前是一个数组
> * `I`：表示当前数组里的元素都是int类型的，`D`表示double类型
> * `@`：间隔符号，无特殊含义
> * `4eec7777`，真正的地址值

### 6.2 数组元素访问

通过索引访问（下标）

```java
数组名 [索引];
System.out.println(array[0]);
```

数据存入数组

```java
数组名 [索引] = 数据/变量;
array[0] = 10;
```

### 6.3 数组遍历

获取数组长度：

```java
int l = array.length;
```

循环遍历：

```java
for (int i = 0; i < array.length; i++) {
    System.out.println(array[i]);
}
```

> ## IDEA快速生成数组遍历代码
>
> idea中输入
>
> ```java
> 数组名.fori  -> 回车
> ```

### 6.4 动态初始化

初始化时只指定数组长度，由系统为数组分配初始值。

```JAVA
数据类型[] 数组名 = new 数据类型[数组长度];
int[] array = new int[5];
```

* 可之后赋值 

**数组默认初始化值的规律**：

整数类型：默认初始化值 `0`

小数类型：默认初始化值 `0.0`

字符类型：默认初始化值 `/u0000` - 空格

布尔类型：默认初始化值 `false`

引用数据类型：默认初始化值 `null`

### 6.5 静态初始化与动态初始化的区别

**动态初始化**：手动指定数组**长度**，由系统给出默认初始化值

* 场景：只明确元素个数，不明确具体数值，推荐使用动态初始化

**静态初始化**：手动指定数组**元素**，系统会根据元素个数，计算出数组的长度

* 场景：需求中已经明确了要操作的具体数据，直接静态初始化即可

### 6.6 数组常见问题

当访问了数组中不存在的索引时，会触发索引越界异常。如：

```java
int[] arr = {1, 2, 3};
System.out.println(arr[10]);
```

### 6.7 数组常见操作

**1.求最值**

定义max变量准备记录擂台上的变化

```java
int max = arr[0];
```

遍历数组获得每一个元素

```java
for (int i = 1; i < arr.length; i++) {
    arr[i]
}
```

让每一个元素与max进行比较，如果找到更大的，就让max记录该元素

```java
for (int i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
        max = arr[i]
    }
}
```

### 6.8 Java内存分配

几类内存

* 栈：方法运行时使用的内存，比如main方法运行，进入方法栈中执行
* 堆：存储对象或数组，new来创建的，都存储在堆内存
* 方法区：存储可运行的class文件
* 本地方法栈：JVM在使用操作系统功能的时候使用，和我们开发无关
* 寄存器：给CPU使用，和我们开发无关

**规律**：

* 只要是 `new` 出来的，一定是在堆里开辟了一个小空间
* 当两个数组指向同一片小空间时，其中一个数组对小空间中的值发生了改变，那么其他数组再次访问的时候都是修改之后的结果

**举例：**

当创建一个数组

```java
int[] arr = new int[2];
```

此时--

* 栈内存

  * int[] arr = 地址值

* 堆内存

  * 地址值 -> 存储真实值

    ```html
    int[]
    length 2
    0 0
    1 0
    ```

如果创建数组时使用其他数组值初始化

```java
int[] arr = {11, 22};
int[] arr2 = arr;
```

则此时：

* arr = 地址值
* arr2 = arr记录的同样的地址值

即两个数组指向同一片堆内存

---

## 7.方法

方法是程序中最小的执行单元

### 7.1 方法定义

把一些代码打包在一起，该过程称为方法定义

**最简单的方法定义与调用方式**

```java
public static void 方法名 () {
    方法体;
}
```

调用

```java
方法名();
```

**带参数的方法定义与调用**：

```java
public static void 方法名 (数据类型 参数1, 数据类型 参数2) {
    方法体;
}
```

调用

```java
方法名(参数1, 参数2);
```

* 调用参数要与定义时的类型与数量一致

形参：方法定义时的参数

实参：方法调用时的参数

**带返回值的方法定义与调用**：

```java
public static 返回值类型 方法名 (数据类型 参数1, 数据类型 参数2) {
    方法体;
    return 返回值;
}
```

调用

* 直接调用

```java
方法名(实参);
```

* 赋值调用

```java
int num = 方法名(实参);
```

### 7.2 方法重载

* 在同一个类中，定义了多个同名的方法，这些同名的方法具有同种的功能

* 每个方法具有不同的参数类型或参数数量，这些同名的方法，就构成了重载关系

* 不看返回值

> ## 几种输出语句
>
> * 先打印，再换行
>
> ```java
> System.out.println("abc");
> System.out.println();  // 只换行
> ```
>
> * 只打印，不换行
>
> ```java
> System.out.print("abc")
> ```
>
> * 格式化打印
>
> ```java
> System.out.printf("i = %d", i);
> ```

### 7.3 方法内存分配

方法运行时实用的内存，方法进栈运行，运行完毕就出栈

举例：
```java
public class MethodDemo {
    public static void main(String[] args) {
        eat();
    }
    public static void eat() {
        study();
        System.out.println("吃饭");
        sleep();
    }
    public static void sleep() {
        System.out.println("睡觉");
    }
    public static void study() {
        System.out.println("学习");
    }
}
```

内存执行顺序：
```html
main(eat(study(打印学习) -> 打印吃饭 -> sleep(打印学习)))
```

 ### 7.4 方法传递形参

**形参是基本数据类型时**

方法传递基本数据类型时，作用范围在栈内存的该方法范围内，也就是说，形参的值改变不会影响实参

例：

```java
int a = 100;
public static void f(int a) {
    a = 200;
}
System.out.println(a); // a还是100
```

若想修改，则需使用返回，调用处赋值。

**形参是引用数据类型时**

方法传递引用数据类型时，传递的是地址值，形参的改变，会影响实际参数的

---

## 8.二维数组

### 8.1 二维数组的静态初始化

格式：

```java
数据类型[][] 数组名 = new 数据类型[][] {{元素1, 元素2}, {元素1,元素2}};
```

示例：

```java
int[][] arr = new int[][] {{11, 22}, {33, 44}};
```

**简化形式**：

```java
数据类型[][] 数组名 = {{元素1, 元素2}, {元素1, 元素2}};
```

示例：

```java
int[][] arr = {{11, 22}, {33, 44}};
```

二维数组表示一维数组中的每个元素也是一个素组，比如`int[i][j]`：

* i 表示二维数组的第 i 个元素
* j 表示二维数组中的一维数组的第 j 个元素

### 8.2 二维数组的动态初始化

格式：

```java
数据类型[][] 数组名 = new 数据类型[m][n];
```

* m 表示这个二维数组，可以存放多少个一维数组
* n 表示每一个一维数组里，可以存放多少个元素

示例：

```java
int[][] arr = new int[2][3];
```

* int 默认初始化每个元素为 0 

### 8.3 二维数组的内存情况

```java
int[][] arr = new int[2][3];
```

1. 栈内存创建二维数组变量 `arr`
2. 堆内存开辟第一片数组空间 `arr[2]`，其中每个元素`arr[i]`存放下一步开辟数组空间的地址值
3. 再在堆内存开辟另两片空间 `arr[2][3]`

> ## 二维数组的特殊写法
>
> ### 不指定一维数组的长度
>
> ```java
> int[][] arr = new int[2][];
> 
> int[] arr1 = {11, 22};
> int[] arr2 = {33, 44, 55};
> 
> arr[0] = arr1;
> arr[1] = arr2;
> ```
>
> ### 指定长度同时赋值
>
> 会替换原创建的空一维数组
>
> ```java
> int[][] arr = new int[2][3];
> 
> int[] arr1 = {11, 22};
> int[] arr2 = {33, 44, 55};
> 
> arr[0] = arr1;
> arr[1] = arr2;in
> ```

---

# 面向对象

## 1.设计对象并使用

### 1.1 类和对象

* 类（设计图）：是对象共同特征的描述
* 对象：是真实存在的具体东西
* java中必须先设计类才能获取对象

**1、定义类**：

```java
public class 类名 {
    1、成员变量(代表属性,一般是名词)
    2、成员方法(代表行为,一般是动词)
    3、构造器
    4、代码块
    5、内部类
}
```

**2、获取类的对象**：

```java
类名 对象名 = new 类名();
```

示例：
```java
Phone p = new Phone();
```

**3、使用对象**：

访问属性：`对象名.成员变量`

访问行为：`对象名.方法名`

### 1.2 定义类的注意事项

* 用来描述一类事物的类，专业叫做：**javabean 类**，在 javabean 类中是不写 `main` 方法的

* 以前编写main方法的类，叫：**测试类**，我们可以在测试类中创建 javabean 类的对象并进行赋值调用

* 类名首字母建议大写，需要见名知意，驼峰模式

* 一个Java文件中可以定义多个class类，且只能一个类是 `public` 修饰，而且 `public` 修饰的类名必须成为代码文件名，实际开发中建议一个文件定义一个class类

* 成员变量的完整定义格式是:

  ```java
  修饰符 数据类型 变量名称 = 初始化值;
  ```

  一般无需指定初始化值，存在默认值

  > ### **对象的成员变量默认值规则**
  >
  > | 数据类型 | 明细                   | 默认值 |
  > | -------- | ---------------------- | ------ |
  > | 基本类型 | byte, short, int, long | 0      |
  > |          | float, double          | 0.0    |
  > |          | boolean                | false  |
  > | 引用类型 | 类、接口、数组、String | null   |
  >

---

## 2.封装

### 2.1 对象的设计

封装：对象代表什么，就得封装对应的数据，并提供数据对应的行为。

比如：

* 人画圆，方法定义在圆 `Circle` 类里，`draw()`
* 人关门，方法定义在门 `Door` 类里，`close()`

> ### JDK 文档（EN）
>
> * [JDK 8 文档（EN）](https://docs.oracle.com/javase/8/docs/api/)
> * [JDK 8 文档（中文）](https://www.matools.com/api/java8)

### 2.2 private 关键字

`private` 关键字

* 是一个权限修饰符
* 可以修饰成员（成员变量和成员方法）
* 被 `private` 修饰的成员只能在本类中才能访问

**正确封装方式**：

* 成员变量使用 `private` 关键字
* 使用成员方法 `getXXX()` 获取，`setXXX()` 设置

示例：

```java
public class GirlFriend {
    private int age;
    
    // set赋值
    public void setAge(int a) {
        if (a >= 18 && a <= 50) {
            age = a;
        } esle {
            System.out.println("非法数据");
        }
    }
    
    // get获取
    public int getAge() {
        return age;
    }
}
```

### 2.3 this关键字

可用于区分成员变量与局部变量

**成员变量和局部变量**：

* 当变量定义在类内、方法外，为成员变量
* 当变量定义在类内、方法内，为局部变量
* 当成员变量与局部变量名相同时，直接调用将会参照'就近原则'

如：

```java
public class GirlFriend {
    private int age;
    
    public void setAge(int age) {
        age = age; // 局部变量赋值
    }
}
```

使用this关键字：

```java
public class GirlFriend {
    private int age;
    
    public void setAge(int age) {
        this.age = age;
    }
}
```

**本质与内存图**：

### 2.4 构造方法

构造方法也叫构造器、构造函数，用于在创建对象时给成员变量赋值

格式：

```java
public class Student {
    修饰符 类名(参数) {
    	方法体;
	}
}
```

* 方法名与类名相同，大小写也要一致
* 没有返回值类型，void也没有
* 没有具体的返回值（不能由return带回结果数据）
* 如果自己没有写构造方法，java虚拟机会自动添加一个 空参构造 方法

示例：

```java
public class Student {
    private String name;
    private int age;
    
    public Student() {
        // 空参构造
        this.name = "null";
        this.age = 18;
    }
    
    public Student(String name, int age) {
        // 有参构造
        this.name = name;
        this.age = age;
    }
}
```

执行时机：

* 创建对象时由虚拟机调用，不能手动调用构造方法
* 每创建一次对象，就会调用一次构造方法

### 2.5 标准的JavaBean类

1. 类名需要见名知意
2. 成员变量使用private修饰
3. 提供至少两个构造方法

* 无参构造方法
* 带全部参数的构造方法

4. 成员方法

* 提供每一个成员变量对应的 `setXxx()/getXxx()`
* 如果还有其他行为，也需要写上

### 2.6 对象内存分配

当运行一个类时，字节码文件加载时进入 **方法区** 内存，如：

```java
HelloWorld.class
```

方法运行时进入 **栈** 内存，变量也是在这里

`new` 出来的东西会在 **堆** 内存中开辟空间并产生地址

**创建一个对象时**：

```java
Student s = new Student();
```

1. 加载class文件
   * class文件加载到方法区
2. 申明局部变量
   * 即在栈内存中申明 `Student s`
3. 在堆内存中开辟一个空间
   * 在堆内存中声明 `new Student`
   * 开辟空间，生成地址，将方法区的变量拷贝过来，并记录方法区成员方法的地址
4. 默认初始化
   * 比如 `String name = null` `int age = 0`
5. 显示初始化
   * 比如 `String name = "zhangsan"` `int age = 23`
6. 构造方法初始化
   * 空参/有参
7. 将堆内存中的地址值赋值给左边的局部变量

**创建两个对象时**：

* 创建第一个对象时与上面一致

* 创建第二个对象时，方法区已经加载了class文件，不会再加载第二遍，直接使用

* 再在堆空间重新开辟一个独立的空间用于存放第二个对象的相关信息

**两个引用指向同一个对象**：

```java
Student stu1 = new Student();
stu1.name = "阿强";
Student stu2 = stu1;

// 地址赋值
stu1 = null;  // stu2指向的对象还在，只是stu1记录的地址值变为了null
```

* 创建第一个对象时与上面一致
* 直接将地址赋值给第二个对象

若没有变量指向一个对象，则该对象称为垃圾，会被java虚拟机回收

### 2.7 this的内存原理

所在方法调用者的地址值，如：

```java
public class Student() {
    private int age;
    public void method() {
        int age = 10;
        System.out.println(age);   // 就近原则，局部变量age
        System.out.println(this.age);    // 假设调用者的地址值为s(001)，表示调用s(001)的成员变量age
    }
}

public class StudentTest() {
    public static void main(String[] args) {
        Student s = new Student();
        s.method();
    }
}
```

> ### 格式化打印语句 System.out.printf()
>
> 两部分参数：
>
> * 第一部分参数：要输出的内容 `%s` (占位)
>
> * 第二部分参数：填充的数据
>
> 如：
>
> ```java
> System.out.printf("你好啊%s", "张三");
> System.out.printf("%s你好啊%s", "张三", "李四");
> ```
>
> * 没有换行效果

> ### 键盘录入的其他情况
>
> 第一套：
>
> `nextInt()`：接收整数
>
> `nextDouble()`：接收小数
>
> `next()`：接收字符串
>
> * 遇到空格、回车就停止接收，这些符号后的数据都不会接收
>
> 第二套：
>
> `nextLine()`
>
> * 可以接收空格、制表符，遇到回车才停止接收数据
>
> 两套体系不能混用：
>
> * 先用nextInt, 再用nextLine会导致下面的nextLine接收不到数据

---

## 3.API

API(Application Programming Interface)：应用程序接口

### 3.1 API 和 API帮助文档

API：目前是JDK中提供各种功能的Java类

API帮助文档：帮助开发人员更好地使用API和查询API的一个工具

在线文档：
| JDK版本 | URL                               | 语言 |
| ------- | --------------------------------- | ---- |
| JDK 1.8 | https://www.matools.com/api/java8 | 中文 |

> ### java.lang包
>
> * 不需要使用import进行导入
> * 比如 `String` `Math`等

### 3.2 字符串String

**3.2.1 String的创建**

`java.lang.String` 类代表字符串，Java程序中的所有字符串文字（例如“abc”）都为此类的对象

* 字符串的内容不会发生改变，它的对象在创建后不能被更改
* 重新赋值操作其实是新建了一个字符串对象，然后再赋值

**创建String对象的两种方式**：

1. 直接赋值

   ```java
   String name = "xxx";
   ```

2. new 构造方法

* 空参构造，默认值为`""`
* 有参构造-传String
* 有参构造-传字符数组
* 有参构造-传字节数组-查ASCII码

**3.2.2 String的内存模型**

StringTable（串池）

* 直接赋值的方式存在串池
* new 出来的不存在串池
* jdk7之后从方法区挪到了堆内存

**直接赋值**：

当使用双引号直接赋值时，系统会检查该字符串在串池中是否存在

* 不存在则创建新的
* 存在则复用

**3.2.3 String的常用方法**

**1.比较**：

> ### `==` 比的是什么
>
> 1. **基本数据类型**
>
> * 比较的是具体的值
>
> 2. **引用数据类型**
>
> * 比较的是地址值

| 方法名                                     | 格式                              | 作用                              |
| ------------------------------------------ | --------------------------------- | --------------------------------- |
| `boolean equals(要比较的字符串)`           | `字符串.equals(字符串)`           | 完全一样结果才是true，否则为false |
| `boolean equalsIgnoreCase(要比较的字符串)` | `字符串.equalsIgnoreCase(字符串)` | 忽略大小写的比较                  |

* 键盘录入的字符串是 `new` 出来的

**2.获取长度**：

* `.length()` 方法获取长度

```java
String str = "abc";
int len = str.length();
```

**3.根据索引获取字符**：

* `.charAt(index)` 方法，根据index获取字符

**4.截取**：

* `.substring(begin, end)` 方法获取索引位置为[begin, end)之间的字符串
* 截取区间为[begin, end)

```java
String phoneNum = "13800138000";

String begin = phoneNum.substring(0, 3);
String end = phoneNum.substring(7, 11);
```

**5.替换**：

* `.replace(target, replacement)` 方法获取替换目标为指定字符串之后的字符串

### 3.3 StringBuilder

`StringBuilder` 可以看成一个容器，创建之后里面的内容是可变的

* 提高字符串的操作效率

**3.3.1 StringBuilder的创建**

构造方法：

| 方法名                             | 说明                                         |
| ---------------------------------- | -------------------------------------------- |
| `public StringBuilder()`           | 创建一个空白的可变字符串对象，不含有任何内容 |
| `public StringBuilder(String str)` | 根据字符串的内容，来创建可变字符串对象       |

**3.3.2 StringBuilder常用方法**

| 方法名                                  | 说明                                                  |
| --------------------------------------- | ----------------------------------------------------- |
| `public StringBuilder append(任意类型)` | 添加数据，并返回对象本身                              |
| `public StringBuilder reverse()`        | 反转容器中的内容（非返回值）                          |
| `public int length()`                   | 返回长度（字符出现的个数）                            |
| `public String toString()`              | 通过 toString() 就可以实现把StringBuilder转换为String |

> ### 注意
>
> `StringBuilder` 是java已经写好的类，java在底层对它做了一些特殊处理，打印对象不是地址值而是属性值

> ### 链式编程
>
> 当我们在调用一个方法的时候，不需要用变量接收他的结果，可以继续调用其他方法
>
> 例：
>
> ```java
> StringBuilder sb = new StringBuilder();
> sb.append("hello").append(123).append(4.5).append(false).reverse();
> System.out.println(sb);
> ```

### 3.4 StringJoiner

StringJoiner和StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的

作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用

jdk8 出现的

**3.4.1 StringJoiner的创建**

构造方法：

| 方法名                                              | 说明                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| `public StringJoiner(间隔符号)`                     | 创建一个StringJoiner对象，指定拼接时的间隔符号               |
| `public StringJoiner(间隔符号，开始符号，结束符号)` | 创建一个StringJoiner对象，指定拼接时的间隔符号，开始符号，结束符号 |

成员方法：

| 方法名                                | 说明                         |
| ------------------------------------- | ---------------------------- |
| `public StringJoiner add(添加的内容)` | 添加数据，并返回对象本身     |
| `public int length()`                 | 返回长度（字符出现的个数）   |
| `public String toString()`            | 返回一个字符串（拼接之后的） |

> ## 字符串原理回顾
>
> **扩展底层原理1**：字符串存储的内存原理
>
> * 直接赋值会复用字符串常量池中的
> * new出来的不会复用，而是开辟一个新的空间
>
> **扩展底层原理2**：==号比的是什么
>
> * 基本数据类型比较数据值
> * 引用数据类型比较地址值
>
> **扩展底层原理3**：字符串拼接的底层原理
>
> * 没有变量参与：编译时就是最终结果，约等于直接赋值
> * 有变量参与：通过StringBuilder进行拼接与转换为字符串，浪费内存
> * jdk8比jdk7优化，jdk8会先预估长度，创建数组，后转换为字符串
>
> **扩展底层原理4**：StringBuilder提高效率原理图
>
> * StringBuilder是可变容器，不会产生新对象
>
> **扩展底层原理5**：StringBuilder源码分析
>
> * 默认长度16
> * 添加的内容大于16会扩容=原来容量*2+2
> * 扩容之后还不够则以实际长度为准

### 3.5 集合ArrayList

对比数组：

| 数组                           | 集合                                             |
| ------------------------------ | ------------------------------------------------ |
| 可存基本数据类型、引用数据类型 | 可存引用数据类型<br />基本数据类型需变为其包装类 |
| 长度固定                       | 长度可变                                         |

**3.5.1 ArrayList的创建**

**构造方法**

| jdk7                                   | jdk7以后                                  |
| -------------------------------------- | ----------------------------------------- |
| ArrayList<E> list = new ArrayList<E>() | **ArrayList<E> list = new ArrayList<>()** |

打印对象不是地址值，而是集合中存储的数据内容，自动添加“[]”

**成员方法**

| 方法名                  | 说明                                 |
| ----------------------- | ------------------------------------ |
| `boolean add(E e)`      | 添加元素，返回值表示是否添加成功     |
| `boolean remmove(E e)`  | 删除指定元素，返回值表示是否删除成功 |
| `E remove(int index)`   | 删除指定索引的元素，返回被删除的元素 |
| `E set(int index, E e)` | 修改指定索引下的元素，返回原来的元素 |
| `E get(int index)`      | 获取指定索引的元素                   |
| `int size()`            | 集合的长度，也就是集合中元素的个数   |

> ## 循环取别名，跳出外层循环
>
> 在循环前添加别名，格式如下：
> ```java
> loop: while (true) {
>     while (true) {
>         break loop;
>     }
> }
> ```

---

## 4.static关键字

**可以修饰成员方法、成员变量**

加载类时在堆内存创建了一个单独的静态存储区（静态区），该区存储该类所有的静态变量（优先于对象出现）

### 4.1 静态变量

**特点**：

* 被该类所有对象**共享**
* 静态属性不属于对象，**属于类**
* 静态变量是**随着类的加载而加载**，优先于对象存在

**调用方法**：

* **类名调用**（推荐）
* 对象名调用

### 4.2 静态方法

**特点**：

* 多用在测试类和工具类中
* Javabean类中很少会用
* 类名或对象名调用

**工具类**：

1. 类名见名知意
2. **私有化构造方法**
3. 方法定义为**静态**

```java
// 工具类
//1.类名见名知意
public class ArrayUtil { 
    // 2.私有化构造方法
    private ArrayUtil(){}   
    
    // 3.方法定义为静态
    public static int printArr(){}  
}
```

**static注意事项**：

* 静态只能访问静态
* 非静态可以访问所有
* 静态方法中没有this关键字

> ## 重新认识 main 方法
>
> * `public`: 被JVM调用，访问权限足够大
> * `static`: 被JVM调用，不是创建对象，直接类名访问，因为main方法是静态的，所以测试类中其他方法也需要是静态的
> * `void`: 被JVM调用，不需要给JVM返回值
> * `main`：一个通用的名称，虽然不是关键字，但是被JVM识别
> * `String[] args`：以前用于接收键盘录入数据的，现在没用（为了向下兼容低版本）

---

## 5.继承

### 5.1 extends

当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承

* Java只能单继承，不支持多继承，但支持多层继承
* 每一个类直接或间接继承Object类

格式：

```java
public class 子类 extends 父类 {}
```

**子类能继承父类哪些内容？**

|          | 非私有             | 私有（private）               |
| -------- | ------------------ | ----------------------------- |
| 构造方法 | 不能               | 不能                          |
| 成员变量 | 能                 | 能，但不能直接使用（get/set） |
| 成员方法 | 能，但只继承虚方法 | 不能                          |

**关于成员方法**：

虚方法：非private、非static、非final

只有父类中的虚方法才能被子类继承

### 5.2  继承特点

**成员变量的访问特点**：就近原则

**成员方法的访问特点**：直接调用（this）-就近原则，super调用-直接访问父类

**构造方法的访问特点**：

* 子类中所有构造方法默认先访问父类中的无参构造，再执行自己
* 子类构造方法第一行默认：super()，不写也存在，且必须在第一行
* 如果想调用父类的有参构造，必须手动写super()

**方法的重写**：@Override重写注解

* 重写方法的名称、形参列表必须与父类中的一致
* 重写方法的访问权限子类必须大于父类
* 重写方法返回值类型必须小于等于父类
* 只有虚方法表中的方法才能重写

**this、super**：

this:理解为一个变量，表示当前方法调用者的地址值

super:代表父类存储空间

---

## 6.多态

### 6.1 认识多肽

同类型的对象，表现出的不同形态。用父类类型可以接受所有的子类

**表现形式**：**`父类类型 对象名称 = 子类对象`** 

**多态前提**：

* 有继承关系
* 有父类引用指向子类对象
* 有方法重写

### 6.2 多态调用成员的特点

* 变量调用：编译看左边，运行也看左边
* 方法调用：编译看左边，运行看右边

### 6.3 多态的优缺点

优点：

* 多态形式下，右边对象可以实现解耦合，便于扩展和维护
* 定义方法时，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利

弊端：

* 不能调用子类的特有方法

解决方案：

* 变回子类（强制转换）

> ## instanceof 类型判断
>
> ```java
> if (a instanceof Dog) {
>     Dog d = (Dog) a;
> }
> ```
>
> jdk14新特性：判断+强转 合并
>
> * 先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后的变量名为d
> * 如果不是，则不强转，结果直接是false
>
> ```java
> if (a instanceof Dog d) {}
> ```

---

## 7.包

包就是文件夹，用来管理不同功能的java类，方便后期代码维护。

### 7.1 命名规则

公司域名反写 + 包的作用，需要全部英文小写，见名知意。

全类名/全限定名：包名+类名

### 7.2 使用其他类的规则

* 会用同一个包中的类时，不需要导包
* 使用java.lang包中的类时，不需要导包
* 其他情况都需要导包
* 如果同时使用两个包中的同名类，需要用全类名

---

## 8.final关键字

### 8.1 用途

* 修饰 方法：表明该方法是最终方法，不能被重写
* 修饰 类：表明该类是最终类，不能被继承
* 修饰 变量：叫做常量，只能被赋值一次

细节：

* `final`修饰的变量是基本类型：变量存储的**数据值**不能发生改变
* `final`修饰的变量是引用类型：变量存储的**地址值**不能发生改变，对象内部的可以改变

### 8.2 常量

实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性

常量的命名规范：

* 单个单词：全部大写
* 多个单词：全部大写，单词之间用下划线隔开

---

## 9.权限修饰符

### 9.1 权限修饰符的分类

有四种作用范围由小到大（`private` < 缺省/默认 < `protected` < `public`）

| 修饰符      | 同一个类中 | 同一个包中的其他类 | 不同包下的子类 | 不同包下的无关类 |
| ----------- | ---------- | ------------------ | -------------- | ---------------- |
| `private`   | 是         |                    |                |                  |
| 空着不写    | 是         | 是                 |                |                  |
| `protected` | 是         | 是                 | 是             |                  |
| `public`    | 是         | 是                 | 是             | 是               |

### 9.2 代码块

指 `{}` 包裹的部分

1. 局部代码块：淘汰，了解即可

2. 构造代码块：渐渐淘汰，写在成员位置的代码块，优先与构造方法执行

```java
public class Student {
    private String name;
    {
        System.out.println("开始创建对象");
    }
    public Student() {
        System.out.println("空参构造");
    }
    public Student(String name) {
        this.name = name;
    }
}
```

3. **静态代码块**

* 格式：`static{}`
* 特点：需要通过`static`关键字修饰，随着类的加载而加载，并自动触发、只执行一次
* 使用场景：在类加载的时候，做一些数据初始化的时候使用。

---

## 10.抽象类

### 10.1 抽象方法与抽象类

**抽象方法**：将共性的行为（方法）抽取到父类之后。由于每一个子类执行的内容是不一样的，所以，在父类中不能确定具体的方法体。该方法就可以定义为抽象方法。

```java
public abstract 返回值类型 方法名(参数列表);
```

**抽象类**：如果一个类中存在抽象方法，那么该类就必须声明为抽象类。

```java
public abstract class 类名{}
```

### 10.2 抽象类注意事项

* 抽象类不能实例化（创建对象）
* 抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类
* 可以有构造方法
* 抽象类的子类
  * 要么重写抽象类中的所有抽象方法
  * 要么是抽象类

## 11.接口

接口就是一种规则，是对行为的抽象。

### 11.1 接口的定义和使用

* 接口用关键字`interface`来定义

  ```java
  public interface 接口名{}
  ```

* 接口不能实例化

* 接口和类之间是实现关系，通过`implements`关键字表示

  ```java
  public class 类名 implements 接口名 {}
  ```

* 接口的子类（实现类）

  * 要么重写接口中所有的抽象方法
  * 要么是抽象类

注意：

* 接口和类的视线关系，可以**单实现**，也可以**多实现**

  ```java
  public class 类名 implements 接口名1,接口名2 {}
  ```

* 实现类还可以在继承一个类的

### 11.2 接口中成员的特点

成员变量：

* 只能是常量
* 默认修饰符：`public static final`

构造方法：

* 无

成员方法：

* 只能是抽象方法
* 默认修饰符：`public abstract`

jdk7以前：接口中只能定义抽象方法

jdk8新特性：接口中可以定义有方法体的方法

jdk9新特性：接口中可以定义私有方法

### 11.3 接口和类之间的关系

类和类之间的关系

* 继承关系，不能多继承，但是可以多层继承

类和接口的关系

* 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口
* 若有重名方法，则只需要重写一次

接口和接口的关系

* 继承关系，可以单继承，也可以多继承
* 如果实现类实现了最下面的子接口，则需要重写所有的抽象方法

### 11.4 jdk8开始接口中新增的方法

**jdk8以后接口中新增的方法**：

1. 允许在接口中定义默认方法，需要使用关键字`default`修饰--解决接口升级的问题

接口中默认方法定义格式：

```java
public default 返回值类型 方法名(参数列表) {}
```

默认方法的注意事项：

* 默认方法不是抽象方法，所以不强制被重写。但如果被重写，重写的时候**去掉`default`关键字**
* `public`可以省略，`default`不能省略
* 如果实现了多个接口，多个接口中存在相同名字的默认方法，**子类必须对该方法进行重写**

2. 允许在接口中定义静态方法，需要用`static`修饰

接口中静态方法定义格式：

```java
public static 返回值类型 方法名(参数列表) {}
```

接口中静态方法注意事项：

* 静态方法只能他哦难过接口名调用，不能通过实现类名或对象名调用
* `public`可以省略，`static`不能省略

**jdk9新增的方法**：

接口中私有方法的定义格式：

```java
private 返回值类型 方法名(参数列表) {}
```

```java
private static 返回值类型 方法名(参数列表) {}
```

当一个方法的参数是接口时，可以传递接口的所有实现类的对象，这种方式称之为接口多态

### 11.5 适配器设计模式

设计模式（Design pattern）：是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。

简单理解：设计模式就是各种套路

适配器设计模式：**解决接口与接口实现类之间的矛盾问题**

1. 当一个接口中抽象方法过多，但是我们只要使用其中的一部分的时候，就可以使用适配器设计模式
2. 书写步骤：

* 编写中间类`XXXAdapter`，实现对应的接口
* 对接口中的抽象方法进行空实现
* 让真正的实现类继承中间类，并重写需要用的方法
* 为了避免其他类创建适配器类的对象，中间的适配器类用abstract进行修饰

## 12.内部类

类的五大成员：

属性、方法、构造方法、代码块、内部类

### 12.1 认识内部类

内部类：在一个类的里面，再定义一个类

* 内部类表示的事物是外部类的一部分
* 内部类单独出现没有任何意义

内部类的访问特点：

* 内部类可以直接访问外部类的成员，包括私有
* 外部类要访问内部类的成员，必须创建对象

### 12.2 内部类的分类

1. 成员内部类（了解）：写在成员位置的，属于外部类的成员

* 写在成员位置，属于外部类的成员
* 成员内部类可以被一些修饰符修饰，比如：private，默认，protected，public，static等
* 成员内部类里面，jdk16之前不能定义静态变量，jdk16开始才可以定义静态变量

获取成员内部类对象

* 在外部类中编写方法，对外提供内部类的对象

* 直接创建格式：

  ```java
  外部类名.内部类名 对象名 = 外部类对象.内部类对象;
  ```

外部类成员变量和内部类成员变量重名时，在内部类中如何访问

* ```java
  System.out.println(Outer.this.变量名);
  ```

2. 静态内部类（了解）：成员内部类 + `static`关键字

* 静态内部类中只能访问外部类的静态变量和静态方法，如果想要访问非静态的需要创建外部类的对象

创建静态内部类对象的格式：

* ```java
  外部类名.内部类名 对象名 = new 外部类名.内部类名();
  ```

调用非静态方法的格式：先创建对象，用对象调用

调用静态方法的格式：外部类名.内部类名.方法名();

3. 局部内部类（了解）：将内部类定义在方法里面，类似于方法里面的局部变量

* 外界是无法直接使用局部内部类的，需要在方法内部创建对象并使用
* 该类可以直接访问外部类的成员，也可以访问方法内的局部变量

4. **匿名内部类**：本质是隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置

整体包含：

* 继承 / 实现
* 方法的重写
* 创建对象

整体就是一个类的**子类对象或者接口的实现类对象**

```java
new 类名或接口名() {
    重写方法;
};
```

使用场景：

* 当方法的参数是接口或类时，
* 以接口为例，可以传递这个接口的实现类对象，
* 如果实现类只要使用一次，就可以使用匿名内部类简化代码

---

---

# 常用API

## 1.Math

* 是一个帮助用于进行数学计算的工具类
* 私有化构造方法，所有的方法都是静态的

## 2.System

提供了一些与系统相关的方法

C语言的生日、计算机中的时间原点：1970年1月1日 00:00:00

我国：1970年1月1日 08:00:00

| 方法名                                                       | 说明                                               |
| ------------------------------------------------------------ | -------------------------------------------------- |
| `public static void exit(int status)`                        | 终止当前运行的Java虚拟机,0表示当前虚拟机是正常停止 |
| `public static long currentTimeMillis()`                     | 返回当前系统的时间毫秒值形式                       |
| `public static void arraycopy(数据源数组, 其起始索引, 目的地数组, 起始索引, 拷贝个数)` | 拷贝数组                                           |

注意：

`public static void arraycopy`：

* 基本数据类型需要两者保持一致
* 注意超出范围也会报错
* 引用数据类型可以拷贝

`System.out.println()`:

* 打印一个对象时，底层会调用对象的toString方法
* 然后再打印

---

## 3.Runtime

Runtime表示当前虚拟机的运行环境

| 方法名                                | 说明                         |
| ------------------------------------- | ---------------------------- |
| `public static Runtime getRuntime()`  | 当前系统的运行环境对象       |
| `public void exit(int status)`        | 停止虚拟机                   |
| `public int availableProcesssors()`   | 获取CPU的线程数              |
| `public long maxMemory()`             | 总内存大小（byte）           |
| `public long totalMemory()`           | 已经获取的总内存大小（byte） |
| `public long freeMemory()`            | 剩余内存大小                 |
| `public Process exec(String command)` | 运行cmd命令                  |

获取Runtime对象：

```java
Runtime r1 = Runtime.getRuntime;
```

---

## 4.Object & Objects

Object是Java中的顶级父类。所有的类直接或间接继承与Object。

### 4.1 构造方法

只有空参构造

| 方法名            | 说明     |
| ----------------- | -------- |
| `public Object()` | 空参构造 |

### 4.2 成员方法（常见）

| 方法名                               | 说明                     |
| ------------------------------------ | ------------------------ |
| `public String toString()`           | 返回对象的字符串表示形式 |
| `public boolean equeals(Object obj)` | 比较两个对象是否相等     |
| `protected Object clone()`           | 对象克隆                 |

注意：

`public boolean equeals(Object obj)`：

* 若没有重写，默认使用`==`比较两者地址值

### 4.3 `protected Object clone()`

* 需要重写`clone`方法

* 是 `protected` 方法，所以默认只能在类内部或子类中使用。
* 返回的是一个 `Object`，你通常需要强制类型转换回来。
* 需要类实现 `Cloneable` 接口，否则会抛出 `CloneNotSupportedException`。



> ## `Cloneable` 是什么？
>
> 如果一个接口里面没有抽象方法，表示当前接口是一个标记性接口
>
> `Cloneable` 是 Java 中的一个 **标记接口（Marker Interface）**，位于 `java.lang` 包中：
>
> ```java
> public interface Cloneable {}
> ```
>
> 它没有任何方法，就是一个“标签”或者“标记”，表示**这个类的对象可以被 `clone()` 方法克隆**。
>
> ## 为什么需要实现 `Cloneable` 接口？
>
> 如果你调用 `Object` 类的 `clone()` 方法，而你的类没有实现 `Cloneable` 接口，会抛出异常：
>
> ```java
> CloneNotSupportedException
> ```
>
> 也就是说：
>
> > 不实现 `Cloneable`，不能用 `clone()`！
>
> ## 浅克隆深克隆
>
> Object中的clone()是浅克隆
>
> | 名称                        | 含义                                                         |
> | --------------------------- | ------------------------------------------------------------ |
> | **浅克隆（Shallow Clone）** | 只复制对象的**基本类型字段**和**引用地址**，不复制引用对象本身。 |
> | **深克隆（Deep Clone）**    | 不仅复制对象本身，还递归复制它里面所有引用的对象，彻底复制整个对象结构。基本数据类型直接拷贝，字符串复用，引用数据类型重新创建新的。 |
>
> 深克隆需要在浅克隆的基础上手动创建

正确写法：

```java
class Dog implements Cloneable {
    String name;

    Dog(String name) {
        this.name = name;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // 合法
    }
}

public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        Dog d1 = new Dog("旺财");
        Dog d2 = (Dog) d1.clone();

        System.out.println(d1 == d2); // false
        System.out.println(d1.name.equals(d2.name)); // true
    }
}
```

### 4.4 Objects

Objects是一个工具类，提供了一些方法去完成一些功能。

成员方法：

| 方法名                              | 功能                                    |
| ----------------------------------- | --------------------------------------- |
| `Objects.equals(a, b)`              | 安全比较两个对象是否相等（避免 NPE）    |
| `Objects.hash(...)`                 | 快速生成对象的 hashCode                 |
| `Objects.requireNonNull(obj)`       | 判空，如果为 null 抛异常                |
| `Objects.toString(obj)`             | 安全调用 `toString()`，null 返回 "null" |
| `Objects.compare(a, b, comparator)` | 自定义比较两个对象                      |
| `Objects.isNull(obj)`               | 判断是否为空，为Null返回True            |
| `Objects.nonNull(obj)`              | 判断是否为空，为Null返回False           |

---

## 5.BigInteger

构造方法：

| 方法名                                     | 说明                                   |
| ------------------------------------------ | -------------------------------------- |
| `public BigInteger(int num, Random rnd)`   | 获取随机大整数，范围：[0~2的num次方-1] |
| `public BigInteger(String val)`            | 获取指定的大整数                       |
| `public BigInteger(String val, int radix)` | 获取指定进制的大整数                   |

常用方法：

| 方法名                                       | 说明                   |
| -------------------------------------------- | ---------------------- |
| `public static BigInteger valueOf(long val)` | 静态方法获取BigInteger |



---

## 6.BigDecimal

`BigDecimal` 是 Java 提供的**高精度数字计算类**，属于 `java.math` 包，用于处理 **浮点数精度丢失问题**。

* 用于小数的精确计算
* 用来表示很大的小数

构造方法：

| 方法名                          | 说明                                       |
| ------------------------------- | ------------------------------------------ |
| `public BigDecimal(String val)` | 字符串创建                                 |
| `public BigDecimal(double val)` | double类型的小数创建，❌ 不推荐，有精度问题 |

常用方法：

| 方法                                                   | 说明                         | 示例                                   |
| ------------------------------------------------------ | ---------------------------- | -------------------------------------- |
| `public static BigDecimal value of(double / long val)` | 静态方法获取BigDecimal       |                                        |
| `add()`                                                | 加法                         | `a.add(b)`                             |
| `subtract()`                                           | 减法                         | `a.subtract(b)`                        |
| `multiply()`                                           | 乘法                         | `a.multiply(b)`                        |
| `divide()`                                             | 除法（需指定精度和舍入模式） | `a.divide(b, 2, RoundingMode.HALF_UP)` |
| `compareTo()`                                          | 比较大小（返回 -1/0/1）      | `a.compareTo(b)`                       |
| `setScale()`                                           | 设置小数位和舍入方式         | `a.setScale(2, RoundingMode.HALF_UP)`  |

---

## 7.正则表达式

正则表达式（Regular Expression，简称 **Regex**）是一个**用来匹配字符串的模式**，可以用来查找、验证、替换、提取字符串中的内容。

### 7.1 应用场景

| 应用场景 | 示例                                         |
| -------- | -------------------------------------------- |
| 校验     | 判断手机号、邮箱、密码是否合法               |
| 提取     | 从文本中提取邮箱、URL、数字等                |
| 替换     | 替换掉 HTML 标签、空格、特殊符号等           |
| 拆分     | 按多个符号分割字符串（如空格、逗号、制表符） |

 ### 7.2 语法表

字符类（只匹配一个字符）：

| 符号            | 含义                             |
| --------------- | -------------------------------- |
| `[abc]`         | 只能是a, b, 或c                  |
| `[^abc]`        | 除了a,b,c之外的任何字符          |
| `[a-zA-Z]`      | a到z A到Z，包括（范围）          |
| `[a-d[m-p]]`    | a到d，或m到p                     |
| `[a-z&&[def]]`  | d, e, 或f（交集）                |
| `[a-z&&[^bc]]`  | a到z，除了b和c（等同于[ad-z]）   |
| `[a-z&&[^m-p]]` | a到z，除了m到p（等同于[a-lq-z]） |

预定义字符（只匹配一个字符）

| 符号 | 含义                           |
| ---- | ------------------------------ |
| `.`  | 任何字符                       |
| `\d` | 一个数字：[0-9]                |
| `\D` | 非数字：`[^0-9]`               |
| `\s` | 一个空白字符：[\t\n\x0B\f\r]   |
| `\S` | 非空白字符：`[\s]`             |
| `\w` | [a-zA-Z_0-9]英文、数字、下划线 |
| `\W` | [^\w]一个非单词字符            |

数量词

| 符号     | 含义                |
| -------- | ------------------- |
| `X?`     | X，一次或0次        |
| `X*`     | X，0次或多次        |
| `X+`     | X，一次或多次       |
| `X{n}`   | X，正好n次          |
| `X{n, }` | X，至少n次          |
| `X{n,m}` | X，至少n但不超过m次 |

语法表

| 符号       | 含义                            | 示例                       |
| ---------- | ------------------------------- | -------------------------- |
| `.`        | 任意一个字符（除了换行）        | `a.b` 匹配 "acb"、"arb"    |
| `*`        | 重复0次或多次                   | `a*` 匹配 ""、"a"、"aaaa"  |
| `+`        | 重复1次或多次                   | `a+` 匹配 "a"、"aa"        |
| `?`        | 0次或1次                        | `a?` 匹配 "" 或 "a"        |
| `\d`       | 任意数字，相当于 `[0-9]`        | `\d{3}` 匹配3位数字        |
| `\w`       | 字母、数字、下划线              | `\w+` 匹配变量名           |
| `\s`       | 空白字符（空格、\t、\n）        | 用于分词、替换空格         |
| `\W \D \S` | 非对应字符，如`[^0-9]`、`[^\s]` |                            |
| `[]`       | 字符集，匹配其中任意一个        | `[abc]` 匹配 "a"、"b"、"c" |
| `[^]`      | 排除字符集                      | `[^0-9]` 匹配非数字        |
| `^`        | 匹配开头                        | `^abc` 匹配以 "abc" 开头   |
| `$`        | 匹配结尾                        | `abc$` 匹配以 "abc" 结尾   |
| `{n}`      | 正好n次                         | `{2}`                      |
| `{n,}`     | 至少n次                         | `{2,}`至少2次              |
| `{n,m}`    | n-m次                           | `{2,4}`2到4次              |
| `()`       | 分组（用于提取或重复）          | `(ab)+` 匹配 "abab"        |
| `(?i)`     | 忽略后面字符的大小写            | `a((?i)b)c`                |

### 7.3 Pattern和Matcher

Pattern和Matcher

* `Pattern` 是正则表达式的**模式对象**，
* `Matcher` 是用来在字符串上**匹配这个模式**的工具。

| 类        | 类比          | 作用                       |
| --------- | ------------- | -------------------------- |
| `Pattern` | 模板/规则     | 存储正则表达式             |
| `Matcher` | 检测器/执行器 | 在字符串中找符合规则的部分 |

**Pattern类详解**

```java
Pattern pattern = Pattern.compile("\\d+");
```

* `compile(String regex)`：静态方法，接收一个正则表达式，返回一个 `Pattern` 对象。

* `Pattern` 本质上是对正则字符串的“编译结果”，可以复用。

* 可以加匹配模式参数，例如忽略大小写：

  ```java
  Pattern.compile("abc", Pattern.CASE_INSENSITIVE);
  ```

**Matcher类详解**

```java
Matcher matcher = pattern.matcher("abc123");
```

`Matcher` 是用于执行正则表达式匹配的对象。

| 方法                | 说明                                              |
| ------------------- | ------------------------------------------------- |
| `find()`            | 查找是否存在匹配项，返回 true/false（可多次调用） |
| `group()`           | 返回上一次匹配的具体内容                          |
| `matches()`         | 检查整个字符串是否完全匹配                        |
| `start()` / `end()` | 返回匹配内容在字符串中的位置                      |
| `replaceAll()`      | 替换所有匹配到的部分                              |
| `replaceFirst()`    | 只替换第一个匹配                                  |

### 7.4 贪婪爬取/非贪婪爬取

贪婪爬取：在爬取数据时尽可能多的获取数据

非贪婪爬取：在爬取数据时尽可能少的获取数据

* 只写`+`和`*`表示贪婪匹配
* `+?`非贪婪匹配
* `*?`非贪婪匹配

java默认是贪婪爬取，但在数量词`+*`后加上`?`表示非贪婪爬取

### 7.5 捕获分组和非捕获分组

组号从1开始，连续不间断，以左括号为基准，最左边的是第一组

**1.捕获分组**：后续还要继续使用本组的数据

* `\\组号`：表示把第X组的内容再拿出来用一次（正则内部）

* `$组号`：正则外部使用

  ```java
  // 将下面的字符串按规则替换为“我要学编程”
  String str = "我要学学编编编编程程程程程程";
      
  String result = str.replaceAll("(.)\\1+", "$1");
  ```

举例1：只考虑一个`a123a`  `b456b`

```java
String regex1 = "(.).+\\1";
```

举例2：可以有多个字符`abc123abc`  `b456b`  `123789123`

```java
String regex2 = "(.+).+\\1"
```

举例3：开始部分内每个字符也需要一致`aaa123aaa`  `bbb456bbb`  `111789111`

```java
// (.)：把首字母看成一组
// \\2：把首字母再拿出来使用（第二个括号）
// *：作用于\\1，表示后面重复的内容出现0次或多次
String regex3 = "((.)\\2*).+\\1"
```

**2.非捕获分组**：分组之后不再需要使用本组数据，仅仅是把数据括起来，**不占用组号**

| 符号       | 含义                       | 举例              |
| ---------- | -------------------------- | ----------------- |
| `(?:正则)` | 获取所有                   | `Java(?:8|11|17)` |
| `(?=正则)` | 获取前面部分               | `Java(?=8|11|17)` |
| `(?!正则)` | 获取不是指定内容的前面部分 | `Java(?!8|11|17)` |

### 7.6 经典正则例子

| 场景                         | 正则表达式                                 |
| ---------------------------- | ------------------------------------------ |
| 手机号                       | `^1[3-9]\d{9}$`                            |
| 邮箱地址                     | `^\w+@\w+.(com`                            |
| 数字                         | `^\d+$`                                    |
| 密码（6~12位，含字母和数字） | `^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{6,12}$` |

---

## 8.爬虫

简单来说，**爬虫就是程序模拟浏览器向网站发送请求，抓取网页数据，然后提取你需要的内容（比如文字、图片、链接）**。

### 8.1 扩展正则规则

### 8.3 爬虫基本步骤

1. 发送请求（GET/POST）
2. 获取网页响应（HTML）
3. 解析网页内容（HTML/XML/JSON）
4. 提取想要的数据（比如标题、图片、价格等）
5. 保存数据（存入文件、数据库）

### 8.4 常用技术栈

| 技术                       | 用途                 | 备注                                 |
| -------------------------- | -------------------- | ------------------------------------ |
| `Jsoup`                    | 解析 HTML、提取数据  | 非常强大，语法类似 jQuery            |
| `HttpClient` 或 `OkHttp`   | 发送 HTTP 请求       | 可以设置 UA、Cookie、代理等          |
| `Regular Expression`       | 提取内容             | 正则表达式，辅助用                   |
| `Jackson / Gson`           | 解析 JSON 数据       | API 类型网站                         |
| `Thread / ExecutorService` | 多线程抓取           | 提高效率                             |
| `Selenium`                 | 模拟浏览器点击、滚动 | 动态页面或需要登录的网页（高级爬虫） |

### 8.3 一个简单的爬虫案例

爬取wallhaven.cc上一百张壁纸图片

适用的网站类型：

* **结构简单、页面静态的网站**
   如大部分用服务器渲染的新闻站、图片站、博客等

* **没有强反爬机制的网站**
   不强制登录、不要求验证码、不大量限制请求频率

* **允许直接用 HTTP 请求获取页面内容和资源**

环境或依赖：

* jdk1.8
* jsoup1.21

```java
package usc.zhijie;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.util.Random;

/**
 * Hello world!
 *
 */
public class App
{
    private static final String BASE_URL = "https://wallhaven.cc";
    private static final String LIST_URL = BASE_URL + "/toplist?page=";
    private static final int TARGET_COUNT = 100;
    private static final String SAVE_DIR = "D:/MyDdwnload/img/";

    public static void main(String[] args) throws Exception {
        System.setProperty("https.proxyHost", "127.0.0.1");
        System.setProperty("https.proxyPort", "13530");
        int downloaded = 0;

        for (int page = 1; downloaded < 100; page++) {
            // 1. 请求分页地址
            Document doc = Jsoup.connect(LIST_URL + page)
                    .userAgent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36")
                    .timeout(10000)
                    .get();

            // 2. 选中缩略图块，获取详情页链接
            Elements links = doc.select("figure > a.preview");

            for (Element link : links) {
                // 例如：https://wallhaven.cc/w/xxxx
                String detailUrl = link.attr("href");

                // 3. 进入详情页
                Document detailDoc = Jsoup.connect(detailUrl)
                        .userAgent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36")
                        .timeout(10000)
                        .get();

                // 4. 提取原图地址
                Element imgEl = detailDoc.selectFirst("img#wallpaper");
                if (imgEl != null) {
                    // 原图链接
                    String imgUrl = imgEl.attr("src");

                    // 5. 下载图片
                    downloadImage(imgUrl, SAVE_DIR);
                    downloaded++;

                    // ✅ 每下载一张图后等待 1~2 秒
                    Thread.sleep(1000 + new Random().nextInt(1000));

                    if (downloaded >= 100) {
                        break;
                    }
                }
            }
        }

    }

    public static void downloadImage(String imgUrl, String saveDir) {
        try {
            // 提取文件名
            String fileName = imgUrl.substring(imgUrl.lastIndexOf("/") + 1);
            String fullPath = saveDir + fileName;

            // 确保保存目录存在
            java.io.File dir = new java.io.File(saveDir);
            if (!dir.exists()) {
                dir.mkdirs();
            }

            // 使用 HttpURLConnection 设置 Referer 头
            java.net.URL url = new URL(imgUrl);
            java.net.HttpURLConnection conn = (java.net.HttpURLConnection) url.openConnection();
            conn.setRequestProperty("Referer", "https://wallhaven.cc/");
            conn.setRequestProperty("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64)");

            // 创建输出流
            try (InputStream in = conn.getInputStream();
                 OutputStream out = new FileOutputStream(fullPath)) {

                byte[] buffer = new byte[2048];
                int len;
                while ((len = in.read(buffer)) != -1) {
                    out.write(buffer, 0, len);
                }

                System.out.println("下载成功: " + fullPath);
            }
        } catch (IOException e) {
            System.err.println("下载失败: " + imgUrl);
        }
    }
}
```

### 8.4 Jsoup

Jsoup 是一个 Java 的 **HTML 解析器 & 网页爬虫工具库**，能帮你：

- 发送网络请求（GET/POST）
- 解析 HTML 文档（DOM 树）
- 使用 CSS 选择器提取元素（超好用）
- 模拟浏览器请求（加请求头、Cookie）

基本组成结构：

| 类                 | 用途                       |
| ------------------ | -------------------------- |
| `Jsoup`            | 工具类，发请求、解析文档   |
| `Document`         | 表示一个 HTML 页面         |
| `Element`          | 表示 HTML 中的某个标签节点 |
| `Elements`         | 一组 `Element` 的集合      |
| `Selector`         | CSS 选择器语法，提取元素   |
| `attr()`, `text()` | 获取属性值/文本内容        |

核心功能：

1. 发送GET请求，获取网页内容

   ```java
   Document doc = Jsoup.connect("https://wallhaven.cc/latest")
           .timeout(10000)
           .get();
   ```

2. 选择器选择元素（CSS 选择器）

   ```java
   Elements links = doc.select("figure > a.preview");
   ```

   | CSS 选择器 | 意义                       |
   | ---------- | -------------------------- |
   | `tag`      | 选中所有某种标签，如 `img` |
   | `.class`   | 根据 class                 |
   | `#id`      | 根据 id                    |
   | `a[href]`  | 带 href 属性的 a 标签      |
   | `div > p`  | 子节点                     |
   | `ul li`    | 后代节点                   |

3. 获取元素信息

   ```java
   for (Element link : links) {
       String detailUrl = link.attr("href"); // 获取 href 属性
       String title = link.text();           // 获取标签文本
   }
   ```

4. 提交 POST 请求（模拟登录等）

   ```java
   Document doc = Jsoup.connect("https://example.com/login")
           .data("username", "myname")
           .data("password", "mypwd")
           .post();
   ```

5. 设置请求头（防止被反爬）

   ```java
   Document doc = Jsoup.connect("https://wallhaven.cc/latest")
           .userAgent("Mozilla/5.0")
           .referrer("https://wallhaven.cc/")
           .header("Accept-Language", "zh-CN")
           .timeout(10000)
           .get();
   ```

6. 使用选择器提取页面元素的多种方式

   提取所有图片的地址：

   ```java
   Elements imgs = doc.select("img");
   for (Element img : imgs) {
       String url = img.attr("src");
   }
   ```

   提取所有链接的文字和 URL：

   ```java
   Elements links = doc.select("a[href]");
   for (Element link : links) {
       System.out.println("Text: " + link.text());
       System.out.println("URL: " + link.attr("href"));
   }
   ```

### 8.5 下载文件

打开文件的 URL → 获取输入流 → 写入到硬盘

使用Java标准库

```java
public static void downloadFile(String fileUrl, String savePath) {
    try (InputStream in = new URL(fileUrl).openStream();
         OutputStream out = new FileOutputStream(savePath)) {

        byte[] buffer = new byte[4096];
        int len;
        while ((len = in.read(buffer)) != -1) {
            out.write(buffer, 0, len);
        }

        System.out.println("下载成功: " + savePath);
    } catch (IOException e) {
        System.err.println("下载失败: " + fileUrl);
        e.printStackTrace();
    }
}
```



---

## 9.jdk时间类

> 全世界的时间，有一个统一的计算标准
>
> 以前以格林威治（GMT）作为标准，现利用铯原子的振动频率计算出来的时间，作为世界标准时间（UTC）。
>
> 中国标准时间：世界标准时间+8小时

### 9.1 jdk7及之前的时间类

Date类是jdk写好的Javabean类，用来描述时间，精确到毫秒。

1. 创建

利用空参构造创建的对象，默认表示当前的系统时间。

```java
Date date = new Date();
```

利用有参构造创建的对象，表示指定的时间

```java
Date date = new Date(指定毫秒值);
```

2. 修改

```java
setTime(毫秒值);
```

3. 获取

```java
getTime();
```

### 9.2 SimpleDateFormat类

* 格式化：把时间变成我们喜欢的格式
* 解析：把字符串表示的时间变成Date类

| 构造方法                                  | 说明                                     |
| ----------------------------------------- | ---------------------------------------- |
| `public SimpleDateFormat()`               | 构造一个SimpleDateFormat，使用默认格式   |
| `public SimpleDateFormat(String pattern)` | 构造一个SimpleDateFormat，使用指定的格式 |

| 常用方法                                | 说明                         |
| --------------------------------------- | ---------------------------- |
| `public final String format(Date date)` | 格式化（日期对象 -> 字符串） |
| `public Date parse(String source)`      | 解析（字符串 -> 日期对象）   |

**常用格式符号：**

| 字母 | 说明               | 示例          |
| ---- | ------------------ | ------------- |
| y    | 年（4位或2位）     | 2023 或 23    |
| M    | 月（1-12）         | 7 或 07       |
| d    | 日                 | 1 或 01       |
| H    | 24小时制小时       | 0-23          |
| h    | 12小时制小时       | 1-12          |
| m    | 分钟               | 0-59          |
| s    | 秒                 | 0-59          |
| S    | 毫秒               | 0-999         |
| E    | 星期几（文本形式） | Tue 或 星期二 |
| a    | 上午/下午标记      | AM / PM       |
| z    | 时区               | PST、GMT+8    |

### 9.3 Calendar类

`Calendar` 是一个**抽象类**，用于处理时间的各个字段（年、月、日、时、分、秒等）的获取与设置，并支持日期的加减操作。

默认实现：

```java
Calendar calendar = Calendar.getInstance();
```

常用字段：

| 常量                   | 含义                                 |
| ---------------------- | ------------------------------------ |
| `Calendar.YEAR`        | 年                                   |
| `Calendar.MONTH`       | 月（注意：0 表示 1月，11 表示 12月） |
| `Calendar.DATE`        | 日                                   |
| `Calendar.DAY_OF_WEEK` | 星期几（1表示星期日）                |
| `Calendar.HOUR`        | 小时（12小时制）                     |
| `Calendar.HOUR_OF_DAY` | 小时（24小时制）                     |
| `Calendar.MINUTE`      | 分钟                                 |
| `Calendar.SECOND`      | 秒                                   |
| `Calendar.MILLISECOND` | 毫秒                                 |

常用方法：

| 方法                         | 说明                   |
| ---------------------------- | ---------------------- |
| `get(int field)`             | 获取某个时间字段的值   |
| `set(int field, int value)`  | 设置某个时间字段的值   |
| `add(int field, int amount)` | 对某个时间字段加减     |
| `getTime()`                  | 获取对应的 `Date` 对象 |
| `setTime(Date date)`         | 设置日期               |

### 9.4 jdk8新增时间类

对比`Date`、`Calendar`、`SimpleDateFormat` 等类

* **线程安全**（不可变）
* **API 清晰**（链式调用、语义明确）
* **功能强大**（支持时区、纳秒、时间段）
* 借鉴了第三方库 Joda-Time 的优秀设计

核心类：

```cpp
java.time 包核心类：
├── LocalDate         // 只表示 日期（年-月-日）
├── LocalTime         // 只表示 时间（时:分:秒:纳秒）
├── LocalDateTime     // 日期 + 时间（无时区）
├── ZonedDateTime     // 日期 + 时间 + 时区
├── Instant           // 时间戳（UTC瞬时时间）
├── Duration          // 时间段（两时刻间的间隔）
├── Period            // 日期段（两个日期之间的年/月/日）
├── DateTimeFormatter // 线程安全的格式化工具
```

Date类：

* `ZoneId`：时区
* `Instant`：时间戳
* `ZoneDateTime`：带时区的时间

日期格式化类：

* `DateTimeFormatter`：用于时间的格式化和解析

日历类：

* `LocalDate`：年、月、日
* `LocalTime`：时、分、秒
* `LocalDateTime`：年、月、日、时、分、秒

工具类：

* `Duration`：时间间隔（秒，纳秒）
* `Period`：时间间隔（年，月，日）
* `ChronoUnit`：时间间隔（所有单位）

---

## 10.包装类

**包装类（Wrapper Class）** 是 Java 为 **每个基本数据类型** 提供的 **类型的封装版本**，让它们也可以像对象一样使用。

> ### 为什么需要包装类？
>
> 1. **集合类不能存基本类型**：
>
> - 例如：`ArrayList<int>` 是不合法的，必须写成 `ArrayList<Integer>`
> - 因为集合只存**对象**
>
> 2. **需要面向对象的操作**
>
> - 包装类有很多方法，比如：
>
>   ```java
>   Integer.parseInt("123"); // 字符串转 int
>   Double.isNaN();          // 判断是否是非法数字
>   ```
>
> 3. **自动装箱 / 拆箱（JDK5 之后）**
>
> - Java 会自动把 `int` 转成 `Integer`，也会自动反过来转换，这个叫“装箱”和“拆箱”

### 10.1 Java中8个基本类型及对应包装类

| 基本类型（primitive） | 包装类（Wrapper）  |
| --------------------- | ------------------ |
| `byte`                | `Byte`             |
| `short`               | `Short`            |
| `int`                 | `Integer` ✅ 最常用 |
| `long`                | `Long`             |
| `float`               | `Float`            |
| `double`              | `Double`           |
| `char`                | `Character`        |
| `boolean`             | `Boolean`          |

### 10.2 Integer

自动、手动装箱：

```java
int x = 10;
Integer y = Integer.valueOf(x); // 手动装箱

// 自动装箱（JDK5+之后）
Integer a = 10;   // 自动装箱 int ➜ Integer
int b = a;        // 自动拆箱 Integer ➜ int
```

常用构造和静态方法：

```java
Integer i1 = Integer.valueOf(123);         // 推荐 ✅（会走缓存）
Integer i2 = Integer.parseInt("456");      // 字符串转 int
Integer i3 = Integer.valueOf("789");       // 字符串转 Integer
```

缓存机制：

```java
Integer x = 100;
Integer y = 100;
System.out.println(x == y);        // true（引用地址一样）
System.out.println(x.equals(y));   // true（值也一样）

Integer a = 200;
Integer b = 200;
System.out.println(a == b);        // false（引用地址不一样）
System.out.println(a.equals(b));   // true（值一样）
```

> ### "=="和".equals()"的区别：
>
> | 比较方式    | 比较内容             |
> | ----------- | -------------------- |
> | `==`        | 比较“对象的引用地址” |
> | `.equals()` | 比较“对象的值”       |

常用方法：

| 方法名                | 说明                             |
| --------------------- | -------------------------------- |
| `parseInt(String)`    | 字符串转 int                     |
| `valueOf(String)`     | 字符串转 Integer（包装类）       |
| `toString()`          | 转字符串                         |
| `compareTo(Integer)`  | 比较两个 Integer 的大小          |
| `intValue()`          | 拆箱为 int                       |
| `equals(Object)`      | 比较值是否相等（推荐用它）       |
| `toBinaryString(int)` | 转二进制字符串                   |
| `toHexString(int)`    | 转十六进制字符串                 |
| `toOctalString(int)`  | 转八进制字符串                   |
| `bitCount(int)`       | 统计 int 值中“1”的个数（位运算） |

进制转换：

```java
System.out.println(Integer.toBinaryString(10)); // "1010"
System.out.println(Integer.toOctalString(10));  // "12"
System.out.println(Integer.toHexString(10));    // "a"
```

---

## 11.Arrays

`java.util.Arrays` 是一个 **工具类**，用于**操作数组的常用方法**集合，比如：

- 排序
- 查找
- 填充
- 复制
- 比较
- 转字符串

它只服务于 Java 中的**数组类型（int[]、String[] 等）**，不是集合（比如 ArrayList）。

### 11.1 常用方法

| 方法名                                          | 说明                           | 返回                                  |
| ----------------------------------------------- | ------------------------------ | ------------------------------------- |
| `Arrays.toString(array)`                        | 打印一维数组                   | 字符串                                |
| `Arrays.deepToString(array)`                    | 打印多维数组                   |                                       |
| `Arrays.sort(array)`                            | 排序（默认基本数据类型升序）   | void                                  |
| `Arrays.copyOf(array, newLength)`               | 复制数组                       | 数组                                  |
| `Arrays.copyOfRange(array, fromIndex, toIndex)` | 范围复制数组（包头不包尾）     | 数组                                  |
| `Arrays.equals(arr1, arr2)`                     | 比较是否相等                   |                                       |
| `Arrays.fill(array, value)`                     | 用值填充数组                   | void                                  |
| `Arrays.binarySearch(array, key)`               | 二分查找（必须先排序，且升序） | 元素存在返回索引，不存在返回-插入点-1 |
| `Arrays.asList(...)`                            | 数组转列表（固定长度）         |                                       |
| `Arrays.stream(array)`                          | 数组转 Stream 流（Java 8+）    |                                       |

关于重载方法`Arrays.sort(array, sortRule)`：

* 根据排序规则排序，只能给引用数据类型，基本数据类型需要用包装类
* 第二个参数是一个接口，在调用方法的时候需要传递这个接口的**实现类对象**，作为排序的规则，只使用一次，可使用匿名内部类的方式
* 底层采用插入排序 + 二分查找方式进行排序

比如：

```java
Arrays.sort(arr, new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o1 - o2; // 升序
        return o2 - o1; // 降序
    }
})
```

compare方法：
参数一o1：表示在无需序列中，遍历得到的每一个元素

参数二o2：有序序列中的元素

返回值：

负数：表示当前插入的元素是小的，放在前面

正数/0：表示当前要插入的元素是大的/相等的，放后面

---

## 12.Lambda表达式

### 12.1 Lambda表达式介绍

函数式编程思想的体现，JDK8开始的新语法

* 用来简化函数式接口的匿名内部类的书写
* 只能简化**函数式接口**的匿名内部类的写法
* 函数式接口：
  * **有且仅有一个抽象方法**的接口叫做函数式接口，接口上方可以加`@FunctionalInterface`注解

关心做什么而不是谁去做

比如(11.1中的例子)：完整格式

```java
Arrays.sort(arr, (Integer o1, Integer o2) -> {
        return o1 - o2; // 升序
        return o2 - o1; // 降序
    }
);
```

### 12.2 Lambda表达式省略规则

1. 参数类型可以省略不写

   ```java
   Arrays.sort(arr, (o1, o2) -> {
           return o1 - o2; // 升序
           return o2 - o1; // 降序
       }
   );
   ```

2. 如果只有一个参数，参数类型可以省略，同时()也可以省略

   ```java
   Arrays.sort(arr, o1 -> {
       XXX
       }
   );
   ```

3. 如果Lambda表达式的方法体只有一行，大括号、分号、return可以省略不写，需要同时省略

   ```java
   Arrays.sort(arr, (o1, o2) -> o1 - o2); // 升序
   
   Arrays.sort(arr, (o1, o2) -> o2 - o1); // 降序
   ```

   

---

---

# 常见算法

## 1.查找

### 1.1 二分查找

前提条件：数组中的数据必须是**有序**的

核心逻辑：每次排除一半的查找范围

* min和max表示当前要查找的范围
* mid是min和max中间的
* 如果要查找的元素在mid的左边，缩小范围时，min不变，max等于mid-1
* 如果要查找的元素在mid的右边，缩小范围时，max不变，min等于mid+1

```java
    public static int binarySearch(int[] arr, int number) {
        int min = 0;
        int max = arr.length - 1;

        while (true) {
            if (max < min) {
                return -1;
            }

            int mid = (min + max) / 2;

            if (arr[mid] == number) {
                return mid;
            } else if (arr[mid] < number) {
                min = mid + 1;
            } else {
                max = mid - 1;
            }
        }
    }
```

### 1.2  插值查找

二分查找的改进

```java
mid = min + (key-arr[min]) / (arr[max] - arr[min]) * (max - min)
```

### 1.3 斐波那契查找

```java
mid = min + 黄金分割点左边长度 - 1
```

都是通过不断缩小范围进行查找

不同点：mid的计算方式不同

### 1.4 分块查找

分块的原则1：前一块中的最大数据，小于后一块中所有的数据（块内无需，块间有序）

分块的原则2：块数数量一般等于数字的个数开根号，比如：16个数字一般分为4块左右

核心思路：先确定要查找的元素在哪一块，然后在块内挨个查找

### 1.5 扩展的分块查找（无规律的数据）

分块原则：块与块之间无交集

---

## 2.排序

### 2.1 冒泡排序

1. 相邻的数据两两比较，小的放前，大的放后
2. 第一轮循环结束，最大值已经找到，在数组的最右边
3. 第二轮循环只要在剩余的元素找到最大值即可
4. 第二轮循环结束，次大值已经确定，第三轮循环继续在剩余数据中循环

```java
    private static void bubbleSort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
```

### 2.2 选择排序

从0索引开始，拿着每一个索引上的元素跟后面的元素依次比较，小的放前面，大的放后面，以此类推

1. 从0索引开始，跟后面的元素一一比较
2. 小的放前面，大的放后面
3. 第一轮循环结束后，最小的数据已经确定
4. 第二轮循环从1索引开始以此类推

```java
    private static void selectionSort(int[] arr2) {
        for (int i = 0; i < arr2.length - 1; i++) {
            for (int j = i + 1; j < arr2.length; j++) {
                if (arr2[i] > arr2[j]) {
                    // 交换
                    int temp = arr2[i];
                    arr2[i] = arr2[j];
                    arr2[j] = temp;
                }
            }
        }
    }
```

### 2.3 插入排序

将0索引的元素到N索引的元素看作是有序的，把N+1索引的元素到最后一个当成是无序的。便利无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。

N的范围：0~最大索引

```java
    private static void insertionSort(int[] arr) {
        // 1.找到无序的那一组数据是从哪个位置开始的
        int startIndex = -1;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > arr[i + 1]) {
                startIndex = i + 1;
                break;
            }
        }

        // 2.便利从startIndex开始到数组末尾的每一个元素
        for (int i = startIndex; i < arr.length; i++) {
            int j = i;

            // 3.将当前元素插入到前面已经排序好的数组中
            while (j > 0 && arr[j] < arr[j - 1]) {
                // 移动元素
                int temp = arr[j];
                arr[j] = arr[j - 1];
                arr[j - 1] = temp;
                j--;
            }
        }
    }
```

> ## 递归算法
>
> ### 递归算法概念
>
> 递归是指方法中调用方法本身的现象
>
> 递归一定要有出口，否则就会出现内存溢出
>
> ### 递归算法的作用
>
> 把一个复杂的问题层次转化为一个与原问题相似的规模较小的问题来求解
>
> 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算
>
> ### 递归算法两个核心
>
> * 找出口：什么时候不再调用方法
> * 找规则：如何把大问题变成规模较小的问题

### 2.4 快速排序

第一轮：把0索引的数字作为基准数，确定基准数在数组中正确的位置。比基准数小的全部在左边，比基准数大的全部在右边

后面以此类推

```java
    /**
     * 参数1：要排序的数组
     * 参数2：排序的起始位置
     * 参数3：排序的结束位置
     * @param arr
     */
    private static void quickSort(int[] arr, int i, int j) {
        int start = i;
        int end = j;

        // 递归出口
        if (start >= end) {
            return;
        }

        // 记录基准数
        int baseNumber = arr[i];

        while (start != end) {
            // 从右往左找比baseNumber小的数
            while (end > start && arr[end] >= baseNumber) {
                end--;
            }
            // 从左往右找比baseNumber大的数
            while (start < end && arr[start] <= baseNumber) {
                start++;
            }
            // 交换两个数
            if (start < end) {
                int temp = arr[start];
                arr[start] = arr[end];
                arr[end] = temp;
            }
        }

        // 将基准数放到正确的位置
        arr[i] = arr[start];
        arr[start] = baseNumber;

        // 递归处理左边的子数组
        quickSort(arr, i, start - 1);
        // 递归处理右边的子数组
        quickSort(arr, end + 1, j);
    }
```

---

---

# 集合进阶

## 1.集合体系结构

### 1.1 集合体系结构

主要分为两类Collection和Map，分别用于存放 **单个元素** 和 **键值对**

```mathematica
java.util
├── Collection（接口）         // 存单个元素
│   ├── List（有序，可重复，有索引）       
│   │   ├── ArrayList（数组结构，查询快） ✅
│   │   ├── LinkedList（链表结构，增删快）
│   │   └── Vector（线程安全，不常用）
│   │
│   ├── Set（无序，不重复，无索引）
│   │   ├── HashSet（基于 Hash，最快） ✅
│   │   ├── LinkedHashSet（有插入顺序）
│   │   └── TreeSet（有序，基于红黑树） ✅
│   │
│   └── Queue（队列）
│       ├── LinkedList（双端队列实现）
│       ├── PriorityQueue（优先队列） ✅
│       └── Deque（双端队列接口）

├── Map（接口）              // 存键值对
│   ├── HashMap（最常用，允许 null 键值） ✅
│   ├── LinkedHashMap（有插入顺序）
│   ├── TreeMap（有序，基于红黑树） ✅
│   └── Hashtable（线程安全，不常用）
│
└── Collections / Arrays（工具类）
```

### 1.2 Collection中的通用方法：

Collection是单列集合的顶层接口，所有方法被List和Set系列集合共享

| 方法                 | 用途 & 备注                                               |
| -------------------- | --------------------------------------------------------- |
| `add(E e)`           | 添加元素，基本的增操作                                    |
| `remove(Object o)`   | 删除指定元素                                              |
| `contains(Object o)` | 判断集合是否包含指定元素，查找用，需要o重写`equals()`方法 |
| `size()`             | 返回集合元素个数                                          |
| `isEmpty()`          | 判断集合是否为空                                          |
| `iterator()`         | 返回迭代器，用于遍历集合（支持增强for）                   |
| `clear()`            | 清空集合                                                  |
| `toArray()`          | 转成数组，方便和数组交互                                  |

## 2.Collection遍历

### 2.1 迭代器遍历（可删除）

迭代器在Java中的类是Iterator，迭代器是集合专用的遍历方式

Collection集合获取迭代器

| 方法名称                | 说明                                    |
| ----------------------- | --------------------------------------- |
| `Iteator<E> iterator()` | 返回迭代器对象，默认指向当前集合的0索引 |

Iterator中的常用方法
| 方法名称            | 说明                                                      |
| ------------------- | --------------------------------------------------------- |
| `boolean hasNext()` | 判断当前位置是否有元素，有元素返回true，没有元素返回false |
| `E next()`          | 获取当前位置的元素，并将迭代器对象移向下一个位置          |

```java
Iterator<E> iterator = collection.iterator();创建指针
while (iterator.hasNext()) {   // 当前是否有元素
    E element = iterator.next();  // 获取元素，移动指针
    System.out.println(element);
}
```

注意：

* 若迭代器指空，再调用.next()会报错NoSuchElementException
* 迭代器遍历完毕不会复位
* 循环中只能用一次next方法
* 迭代器遍历时不能用集合的方法进行增加或删除，若要删除，需使用迭代器的remove方法，但无添加方法

### 2.2 增强for循环（只遍历）

修改for中的变量，**不会改变**集合中原本的数据

```java
for (E element : collection) {
    System.out.println(element);
}
```

### 2.3 Lambda表达式遍历（只遍历）

原匿名内部类写法：
```java
Collection<String> coll = new ArrayList<>();
...
coll.forEach(new Consumer<String>() {
    @Override
    // s表示集合中的每一个数据
    public void accept(String s) {
        ...
    }
})
```

Lambda改法：

```java
collection.forEach(element -> System.out.println(element));
```

## 3.List集合

### 3.1 特有方法

* Collection的方法List都继承了
* List集合有索引，多了很多索引操作的方法

| 方法名                           | 说明                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `void add(int index, E element)` | 在此集合中的指定位置插入指定的元素，原索引位置上的元素依次往后移 |
| `E remove(int index)`            | 删除，返回删除的元素                                         |
| `E set(int index, E element)`    | 修改，返回被修改的元素                                       |
| `E get(int index)`               | 返回指定索引处的元素                                         |

> ## 关于删除的注意
>
> 调用方法时，如果方法出现了重载现象，优先调用实参跟形参类型一致的那个方法
>
> ```java
> List<Integer> list = new ArrayList<>();
> 
> list.add(1);
> list.add(2);
> list.add(3);
> 
> list.remove(1);// 根据索引删除
> ```

### 3.2 list集合的遍历方式：

* 迭代器（`listIterator()`）
  * 额外添加了一个方法，在遍历的过程中，可以添加元素
* 列表迭代器（基础上添加了add方法、previous方法）
* 增强for
* lambda表达式遍历
* 普通for循环（因为List有索引）

> ## 数据结构（简）
>
> ### 1.栈
>
> 特点：先进后出，后进先出
>
> ### 2.队列
>
> 特点：先进先出，后进后出
>
> ### 3.数组
>
> 特点：
>
> * **查询速度快**：通过地址值和索引定位，查询任意数据耗时相同（元素在内存中是连续存储的
> * 删除效率低：要将原始数据删除，同时后面的每个数据前移
> * 添加效率极低：添加位置后的每个数据后移，再添加元素
>
> ### 4.链表
>
> 链表中的结点都是独立的对象，在内存中是不连续的，每个结点包含数据值和下一个结点的地址
>
> 特点：
>
> * 链表查询慢，无论查询哪个数据都要从头开始找
> * 链表**增删快**
>
> 包括单链表和双向链表

### 3.3 ArrayList

底层原理：

* 利用空参构造创建的集合，在底层创建一个默认长度为0的数组
* 添加第一个元素时，底层会创建一个新的长度为10的数组
* 存满时，会扩容1.5倍
* 若一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准

### 3.4 LinkedList

底层数据结构是双链表，查询慢，首尾操作速度极快，所以多了很多首尾操作的特有API

| 特有方法                    | 说明                             |
| --------------------------- | -------------------------------- |
| `public void addFirst(E e)` | 在该列表开头插入指定的元素       |
| `public void addLast(E e)`  | 将指定的元素追加到此列表的末尾   |
| `public E getFirst()`       | 返回此列表中的第一个元素         |
| `public E getLast()`        | 返回此列表中的最后一个元素       |
| `public E removeFirst()`    | 从此列表中删除并返回第一个元素   |
| `public E removeLast()`     | 从此列表中删除并返回最后一个元素 |

## 4.泛型类

### 4.1 泛型类基本介绍

泛型是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查

格式：`<数据类型>`

注意：只能支持**引用数据类型**

使用场景：

* 若没有给集合指定类型，默认认为所有的数据类型都是Object类型，此时可以往集合添加任意的数据类型，这样在获取数据时，无法使用他的特有行为

细节：

* 泛型中不能写基本数据类型，基本数据类型需要使用其**包装类**
* 指定泛型的具体类型后，传递数据时，可以传入该类型或者其子类类型
* 如果不写泛型，类型默认是Object

### 4.2 泛型的使用

**类后面：泛型类**

* 场景：当一个类中，某个变量的数据类型不确定时，就可以定义带有泛型的类

* ```java
  public class ArrayList<E> { }
  ```

* 此处E可理解为变量，但是不是用来记录数据的，而是记录数据的类型，也可写成T、V等

**方法上：泛型方法**

* 场景：方法中形参类型不确定时

* 方案一：使用类名后面定义的泛型——所有的方法都能使用

* 方案二：在方法声明上自己的泛型——只有本方法能使用

* ```java
  public <T> void show(T t) { }
  ```

**接口上：泛型接口**

* ```java
  public interface List<E> { }
  ```

* 使用方式一：实现类给出具体的类型

* ```java
  public class MyArrayList implements List<String> { }
  ```

* 使用方式二：实现类也不确定，创建对象时给出类型

* ```java
  public class MyArrayList<E> implements Lsit<E> {}
  
  MyArrayList<String> list = new MyArrayList<>()
  ```

### 4.3 泛型的继承和通配符：

场景：

* 泛型不具备继承性，但数据具备继承性

* 泛型里写的是什么类型，就只能传递什么类型的数据

* 若本方法虽不确定类型，但希望只能传递某几种类型中的一种

使用通配符`?`：

* `?`可以表示不确定的类型
* 也可进行类型的限定
* `? extends E`：表示可以传递E或者E所有的子类类型
* `? super E`表示可以传递E或者E所有的父类类型

```java
public static void keepPet(ArrayList<? extends Cat> list) { }
```

## 5.Set集合

### 1.6 HashSet集合

* 底层采用哈希表存储数据
* 哈希表是一种对于增删改查数据性能都比较好的结构

> ### 哈希值
>
> 哈希值（Hash Value），也叫“散列值”，是由**哈希函数（Hash Function）根据输入内容计算出来的一个定长的值**，本质上是用来快速查找、比对、定位的。不同的内容理应产生不同的哈希值，相同的内容会产生相同的哈希值。
>
> 对象的整数表示形式
>
> * 根据hashCode方法算出来的int类型的整数
> * 该方法定义在Object类中，所有对象都可以调用，默认使用地址值进行计算
> * 一般情况下，会重写hashCode方法，利用对象内部的属性计算哈希值
>
> 对象的哈希值特点：
>
> * 如果没有重写hashCode方法，不同对象计算出的哈希值是不同的
> * 如果已经重写了hashCode方法，不同对象只要属性值相同，计算出的哈希值就是一样的
> * 小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样（哈希碰撞）

* JDK8之前：数组+链表
* JDK8之后：数组+链表+红黑表

1. 创建一个默认长度为16，默认加载为0.75的数组

2. 根据元素的哈希值跟数组的长度计算出应存入的位置

3. 判断当前位置是否为null，如果是null直接存入

4. 如果位置不为null，表示有元素，则调用equals方法比较属性值

5. 一样：不存  不一样：存入数组，形成链表

6. jdk8以前：新元素存入数组，老元素挂载新元素下面

   jdk8以后：新元素直接挂在老元素下面，而且数组长度大于64时，自动转换为红黑树

### 1.7 LinkedHashSet

原理：底层数据结构依旧是哈希表，知识每个元素又额外多了一个双链表的机制记录存储的顺序

### 1.8 TreeSet

* 不重复，无索引，可排序
* 可排序：按照元素的默认规则（由小到大）排序
* 基于红黑表实现的，增删改查性能都好

排序方式一：

* 默认排序规则
* Student实现Comparable接口，重写里面的抽象方法CompareTo，再指定比较规整

排序方式二：

* 比较器排序
* 创建TreeSet对象时候，传递比较器Comparator指定规则

---

## 2.双列集合

双列集合指的是以**键（Key）-值（Value）对**的形式存储数据的集合，也叫做 **映射（Map）结构**。

```java
Map<Key, Value>
```

一个键只能对应一个值（Key 唯一），但是多个键可以对应相同的值。

**主要实现类：**

| 实现类              | 特点与说明                                           |
| ------------------- | ---------------------------------------------------- |
| `HashMap`           | **最常用的实现类**，无序，允许 null 键和 null 值     |
| `LinkedHashMap`     | 有序（插入顺序），基于 HashMap + 双向链表结构        |
| `TreeMap`           | 可排序的 Map，基于红黑树，键有序（自然排序或自定义） |
| `Hashtable`         | 早期版本的线程安全 Map，不推荐使用                   |
| `ConcurrentHashMap` | 支持并发访问的线程安全 Map（高性能）                 |
| `Properties`        | 专门用于配置文件（`.properties`），键值均为字符串    |

### 2.1 Map常见API

Map是双列集合的顶层接口，它的功能是全部双列集合都可以继承使用的

| 方法                          | 说明                            |
| ----------------------------- | ------------------------------- |
| `put(K key, V value)`         | 添加或更新键值对                |
| `get(Object key)`             | 通过键获取对应的值              |
| `remove(Object key)`          | 删除指定键的键值对              |
| `containsKey(Object key)`     | 判断是否包含某个键              |
| `containsValue(Object value)` | 判断是否包含某个值              |
| `size()`                      | 返回键值对的数量                |
| `isEmpty()`                   | 判断 Map 是否为空               |
| `clear()`                     | 清空所有键值对                  |
| `keySet()`                    | 获取所有键，返回一个 Set        |
| `values()`                    | 获取所有值，返回一个 Collection |
| `entrySet()`                  | 获取所有键值对，返回一个 Set    |

### 2.2 遍历Map的几种方式

1. 遍历所有键

```java
for (String key : map.keySet()) {
    System.out.println("key=" + key + ", value=" + map.get(key));
}
```

2. 遍历所有值

```java
for (String value : map.values()) {
    System.out.println("value=" + value);
}
```

3. 遍历所有键值对

```java
for (Map.Entry<String, String> entry : map.entrySet()) {
    System.out.println("key=" + entry.getKey() + ", value=" + entry.getValue());
}
```

### 2.3 HashMap

* 特点都是由键决定的：无序、不重复、无索引

* HashMap跟HashSet底层原理是一样的，都是哈希表结构

### 2.4 LinkedHashMap

* 由键决定：有序、不重复、无索引
* 有序指保证存储和取出的元素顺序一致
* 底层数据结构依旧是哈希表，知识每个键值对又额外多了一个双链表的机制记录存储的顺序

### 2.5 TreeMap

* TreeMap跟TreeSet底层原理一样，都是红黑树结构的
* 由键决定特性：不重复、无索引、可排序
* 可排序：对键进行排序
* 默认按照键的从小到大排序，也可以自己规定键的排序规律

两种排序规则

* 一：实现Comparable接口，指定比较规则
* 二：创建集合时传递Comparator比较器对象，指定比较规则
* 若两种都有实现，则默认使用第二种方式

---

## 3.Collections

`Collections` 是 Java 提供的一个 **工具类（工具箱）**，用于**操作集合（List、Set、Map）的一些常用方法**，比如排序、查找、同步包装、填充等。

常用API

| 方法名                                           | 作用                                            |
| ------------------------------------------------ | ----------------------------------------------- |
| `addAll(Collection<? super T> c, T... elements)` | 批量添加                                        |
| `sort(List)`                                     | 对列表进行默认升序排序（元素需实现 Comparable） |
| `sort(List, Comparator)`                         | 自定义排序方式（传入比较器）                    |
| `reverse(List)`                                  | 反转列表元素顺序                                |
| `shuffle(List)`                                  | 打乱顺序（洗牌算法）                            |
| `swap(List, i, j)`                               | 交换列表中两个元素位置                          |
| `max(Collection)`                                | 返回最大值                                      |
| `min(Collection)`                                | 返回最小值                                      |
| `frequency(Collection, obj)`                     | 统计某个元素在集合中出现的次数                  |
| `fill(List, obj)`                                | 用某个元素填充整个列表                          |
| `copy(List dest, List src)`                      | 把 src 的内容复制到 dest 中（dest 要先有容量）  |
| `binarySearch(List, key)`                        | 二分查找（列表需先排好序）                      |
| `synchronizedList(List)`                         | 把列表变成线程安全                              |
| `synchronizedMap(Map)`                           | 把 Map 包装成线程安全                           |

---

## 4.不可变集合

**不可变集合** 是指：创建之后 **无法修改（add/remove/set）** 的集合。

包括：

- 不能添加元素
- 不能删除元素
- 不能修改已有元素

场景：

| 场景                | 原因                             |
| ------------------- | -------------------------------- |
| ✅ 保证线程安全      | 多线程下读共享数据时，防止修改   |
| ✅ 保持数据稳定性    | 避免数据被外部不小心修改         |
| ✅ 更安全的 API 设计 | 对外提供的集合不能被调用者改     |
| ✅ 更方便做缓存      | 可直接缓存不可变集合，不担心被改 |

### 4.1 如何创建不可变集合

1. 使用 `Collections.unmodifiableXXX(...)`

```java
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");

List<String> immutableList = Collections.unmodifiableList(list);
immutableList.add("C"); // ❌ 抛出 UnsupportedOperationException
```

⚠️注意：原来的 `list` 改变，`immutableList` 也会变，因为它只是一个**视图包装**！

2.使用 Java 9+ 的工厂方法（更推荐）

```java
List<String> list = List.of("A", "B", "C");
Set<Integer> set = Set.of(1, 2, 3);
Map<String, Integer> map = Map.of("a", 1, "b", 2);
```

---

---

# Stream流

什么是Stream流？

> `Stream` 是对集合（如 List、Set）等数据源进行**函数式处理**的一种方式。

可以理解为：
 📦 **数据流水线** —— 把数据“流”进来，经过一系列操作处理，最后得出结果。

## 1.使用步骤

三大核心：

| 步骤       | 方法例子                              | 说明                     |
| ---------- | ------------------------------------- | ------------------------ |
| 1️⃣ 创建流   | `stream()` / `of(...)`                | 创建数据流               |
| 2️⃣ 中间操作 | `filter()` / `map()` / `sorted()`     | 一系列变换（**懒执行**） |
| 3️⃣ 终止操作 | `collect()` / `forEach()` / `count()` | 真正触发执行并得到结果   |

### 1.1 创建流

获取流水线

| 获取方式     | 方法名                                          | 说明                                     |
| ------------ | ----------------------------------------------- | ---------------------------------------- |
| 单列集合     | `default Stream<E> stream()`                    | Collection中的默认方法                   |
| 双列集合     | 无                                              | 无法直接使用stream流，需先转换为单列集合 |
| 数组         | `public static <T> Stream<T> stream(T[] array)` | Arrays工具类中的静态方法                 |
| 一堆零散数据 | `public static<T> Stream<T> of(T...values)`     | Stream接口中的静态方法                   |

### 1.2 常用的中间操作方法

| 方法名              | 作用                   |
| ------------------- | ---------------------- |
| `filter(Predicate)` | 过滤                   |
| `map(Function)`     | 映射，每个元素转换一次 |
| `sorted()`          | 排序                   |
| `distinct()`        | 去重                   |
| `limit(n)`          | 截取前 n 个元素        |
| `skip(n)`           | 跳过前 n 个元素        |
| `peek()`            | 查看流中元素（调试用） |

### 1.3 常用的终止操作

| 方法名                                      | 作用           |
| ------------------------------------------- | -------------- |
| `collect(Collectors.toList())`              | 转为集合       |
| `forEach(Consumer)`                         | 遍历           |
| `count()`                                   | 统计个数       |
| `findFirst()` / `findAny()`                 | 查找           |
| `allMatch()` / `anyMatch()` / `noneMatch()` | 条件匹配       |
| `reduce()`                                  | 归约（如求和） |

